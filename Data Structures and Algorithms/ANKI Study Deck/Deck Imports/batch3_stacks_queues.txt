#separator:Tab
#html:true
#tags column:3
#deck:DSA Master Deck
What is a stack and what principle does it follow?	A <b>stack</b> is a linear data structure that follows <b>LIFO (Last In, First Out)</b> — the last element added is the first one removed. Think of a stack of plates: you add and remove from the top only.<br><br><b>Core operations:</b><br>• <code>push(item)</code> — add to top: <b>O(1)</b><br>• <code>pop()</code> — remove from top: <b>O(1)</b><br>• <code>peek()/top()</code> — view top without removing: <b>O(1)</b><br>• <code>isEmpty()</code> — check if empty: <b>O(1)</b><br><br>In Python, use a <b>list</b> as a stack: <code>append()</code> to push, <code>pop()</code> to pop.	stacks_queues::stack::fundamentals
What are the time complexities for all stack operations?	<b>All core operations are O(1):</b><br><br>• Push (add to top): <b>O(1)</b><br>• Pop (remove from top): <b>O(1)</b><br>• Peek (view top): <b>O(1)</b><br>• isEmpty: <b>O(1)</b><br>• Search: <b>O(n)</b> — must pop elements to find<br>• Access by index: <b>O(n)</b> — not a native stack operation<br><br><b>Space: O(n)</b> for n elements. The O(1) operations exist because you only ever interact with the top element.	stacks_queues::stack::fundamentals
How do you implement a stack in Python?	Python lists work as stacks natively:<br><pre><code># Using a list<br>stack = []<br>stack.append(1)    # push: [1]<br>stack.append(2)    # push: [1, 2]<br>stack.append(3)    # push: [1, 2, 3]<br>top = stack[-1]    # peek: 3<br>val = stack.pop()  # pop: 3, stack is [1, 2]<br>is_empty = len(stack) == 0<br><br># Using collections.deque (also works)<br>from collections import deque<br>stack = deque()<br>stack.append(1)    # push<br>stack.pop()        # pop</code></pre><br>List is preferred for stacks because <code>append()</code> and <code>pop()</code> are both amortized O(1) from the right end.	stacks_queues::stack::fundamentals
What is the relationship between the call stack and recursion?	Every function call in a program is pushed onto the <b>call stack</b>. Each entry (called a <b>stack frame</b>) stores:<br>• Local variables<br>• Parameters<br>• Return address<br><br>When a recursive function calls itself, a new frame is pushed. When it returns, the frame is popped. This is why:<br>• Recursive space complexity is at least <b>O(depth)</b> — one frame per active call<br>• Too-deep recursion causes <b>stack overflow</b> (Python default limit: ~1000 frames)<br>• Any recursive algorithm can be converted to iterative using an explicit stack	stacks_queues::stack::fundamentals
What is stack overflow and when does it happen?	<b>Stack overflow</b> occurs when the call stack exceeds its memory limit, almost always due to:<br>1. <b>Missing base case</b> in recursion → infinite recursion<br>2. <b>Very deep recursion</b> on large input (even with correct base case)<br><br>Python raises <code>RecursionError</code> at ~1000 frames by default. You can increase it with <code>sys.setrecursionlimit()</code>, but the real fix is usually converting to an iterative approach with an explicit stack.<br><br><b>Interview tip:</b> If a tree could be very deep (skewed), mention that iterative DFS avoids stack overflow risk.	stacks_queues::stack::fundamentals
What is a queue and what principle does it follow?	A <b>queue</b> is a linear data structure that follows <b>FIFO (First In, First Out)</b> — the first element added is the first one removed. Think of a line at a store: first person in line is served first.<br><br><b>Core operations:</b><br>• <code>enqueue(item)</code> — add to back: <b>O(1)</b><br>• <code>dequeue()</code> — remove from front: <b>O(1)</b><br>• <code>peek()/front()</code> — view front without removing: <b>O(1)</b><br>• <code>isEmpty()</code> — check if empty: <b>O(1)</b><br><br>In Python, use <code>collections.deque</code>: <code>append()</code> to enqueue, <code>popleft()</code> to dequeue.	stacks_queues::queue::fundamentals
What are the time complexities for all queue operations?	<b>All core operations are O(1) when using the right implementation:</b><br><br>• Enqueue (add to back): <b>O(1)</b><br>• Dequeue (remove from front): <b>O(1)</b><br>• Peek (view front): <b>O(1)</b><br>• isEmpty: <b>O(1)</b><br>• Search: <b>O(n)</b><br><br><b>⚠️ Warning:</b> Using a Python <code>list</code> as a queue makes dequeue <b>O(n)</b> because <code>list.pop(0)</code> shifts all elements. Always use <code>collections.deque</code> for O(1) operations at both ends.	stacks_queues::queue::fundamentals
How do you implement a queue in Python?	<pre><code>from collections import deque<br><br>queue = deque()<br>queue.append(1)      # enqueue: deque([1])<br>queue.append(2)      # enqueue: deque([1, 2])<br>queue.append(3)      # enqueue: deque([1, 2, 3])<br>front = queue[0]     # peek: 1<br>val = queue.popleft() # dequeue: 1, deque([2, 3])<br>is_empty = len(queue) == 0</code></pre><br><b>Why deque?</b> It's implemented as a doubly linked list of fixed-size blocks, giving O(1) operations at both ends. A regular list gives O(n) for <code>pop(0)</code>.	stacks_queues::queue::fundamentals
What is a deque (double-ended queue)?	A <b>deque</b> supports O(1) insertion and removal at <b>both ends</b>:<br><pre><code>from collections import deque<br>d = deque()<br>d.append(1)       # add right: [1]<br>d.appendleft(0)   # add left:  [0, 1]<br>d.pop()           # remove right: 1<br>d.popleft()       # remove left:  0</code></pre><br><b>Use cases:</b><br>• Sliding window problems (add right, remove left)<br>• When you need both stack AND queue behavior<br>• BFS with level tracking<br>• Monotonic queue (sliding window max/min)<br><br>It's the most flexible linear container — a stack, queue, and double-ended structure all in one.	stacks_queues::queue::fundamentals
What is a circular queue and why is it useful?	A <b>circular queue</b> uses a fixed-size array with <code>front</code> and <code>rear</code> pointers that wrap around using modulo arithmetic:<br><pre><code>self.rear = (self.rear + 1) % self.capacity</code></pre><br><b>Advantages:</b><br>• Fixed memory usage — no dynamic allocation<br>• All operations O(1)<br>• Reuses space freed by dequeue (no wasted slots)<br><br><b>Use cases:</b> Bounded buffers, CPU scheduling, streaming data with fixed buffer size. The "circular" comes from the rear wrapping back to index 0 when it reaches the end of the array.	stacks_queues::queue::fundamentals
What is a priority queue and how does it differ from a regular queue?	A <b>priority queue</b> dequeues the element with the highest (or lowest) priority, not the oldest element:<br><br>• Regular queue: FIFO — first in, first out<br>• Priority queue: highest priority out first, regardless of insertion order<br><br><b>Implementation:</b> Typically a <b>heap</b> (min-heap or max-heap).<br><pre><code>import heapq<br>pq = []<br>heapq.heappush(pq, 3)   # [3]<br>heapq.heappush(pq, 1)   # [1, 3]<br>heapq.heappush(pq, 2)   # [1, 3, 2]<br>val = heapq.heappop(pq) # 1 (smallest)</code></pre><br><b>Time:</b> Enqueue O(log n), Dequeue O(log n), Peek O(1).<br>Covered in depth in the Heaps batch.	stacks_queues::queue::fundamentals
How do you check for balanced brackets/parentheses using a stack?	Push opening brackets, pop and match for closing brackets. If anything mismatches or the stack isn't empty at the end, it's invalid:<br><pre><code>def isValid(s):<br>    stack = []<br>    pairs = {')': '(', ']': '[', '}': '{'}<br>    for char in s:<br>        if char in '([{':<br>            stack.append(char)<br>        elif char in pairs:<br>            if not stack or stack[-1] != pairs[char]:<br>                return False<br>            stack.pop()<br>    return len(stack) == 0</code></pre><br><b>Time: O(n), Space: O(n)</b>. The stack ensures the <b>most recent</b> unmatched opener is the one that must match first — this is exactly why LIFO order works.	stacks_queues::applications
How do you evaluate Reverse Polish Notation (postfix) using a stack?	Operands go onto the stack. When you hit an operator, pop two operands, compute, push the result:<br><pre><code>def evalRPN(tokens):<br>    stack = []<br>    ops = {'+': lambda a,b: a+b, '-': lambda a,b: a-b,<br>           '*': lambda a,b: a*b, '/': lambda a,b: int(a/b)}<br>    for token in tokens:<br>        if token in ops:<br>            b = stack.pop()  # second operand first!<br>            a = stack.pop()<br>            stack.append(ops[token](a, b))<br>        else:<br>            stack.append(int(token))<br>    return stack[0]</code></pre><br><b>Time: O(n), Space: O(n)</b>. Example: ["2","1","+","3","*"] → (2+1)*3 = 9.<br>Note: <code>int(a/b)</code> truncates toward zero in Python 3 (matching expected behavior).	stacks_queues::applications
How do you design a Min Stack that supports getMin() in O(1)?	Maintain a secondary stack that tracks the current minimum at each level:<br><pre><code>class MinStack:<br>    def __init__(self):<br>        self.stack = []<br>        self.min_stack = []<br><br>    def push(self, val):<br>        self.stack.append(val)<br>        min_val = min(val, self.min_stack[-1] if self.min_stack else val)<br>        self.min_stack.append(min_val)<br><br>    def pop(self):<br>        self.stack.pop()<br>        self.min_stack.pop()<br><br>    def top(self):<br>        return self.stack[-1]<br><br>    def getMin(self):<br>        return self.min_stack[-1]</code></pre><br><b>All operations O(1), Space O(n)</b>. The min_stack mirrors the main stack: <code>min_stack[i]</code> = minimum value when the main stack has i+1 elements. Both stacks always have the same size.	stacks_queues::applications
How do you implement a queue using two stacks?	Use one stack for enqueue, another for dequeue. Transfer elements (reversing order) only when the output stack is empty:<br><pre><code>class MyQueue:<br>    def __init__(self):<br>        self.in_stack = []   # for push<br>        self.out_stack = []  # for pop<br><br>    def push(self, x):<br>        self.in_stack.append(x)<br><br>    def pop(self):<br>        self.peek()  # ensures out_stack has elements<br>        return self.out_stack.pop()<br><br>    def peek(self):<br>        if not self.out_stack:<br>            while self.in_stack:<br>                self.out_stack.append(self.in_stack.pop())<br>        return self.out_stack[-1]<br><br>    def empty(self):<br>        return not self.in_stack and not self.out_stack</code></pre><br><b>Push: O(1), Pop: Amortized O(1)</b>. Each element is moved between stacks at most once, so n operations cost O(n) total.	stacks_queues::applications
How do you implement a stack using two queues?	Make push expensive: transfer all elements to the new element's queue so the most recent element is always at the front:<br><pre><code>from collections import deque<br>class MyStack:<br>    def __init__(self):<br>        self.q = deque()<br><br>    def push(self, x):<br>        self.q.append(x)<br>        # Rotate so new element is at front<br>        for _ in range(len(self.q) - 1):<br>            self.q.append(self.q.popleft())<br><br>    def pop(self):<br>        return self.q.popleft()<br><br>    def top(self):<br>        return self.q[0]<br><br>    def empty(self):<br>        return len(self.q) == 0</code></pre><br><b>Push: O(n), Pop: O(1)</b>. After push, all elements are rotated so the newest is at the front. Alternatively, make pop O(n) and push O(1).	stacks_queues::applications
What is the asteroid collision problem pattern?	Asteroids move in a direction (positive = right, negative = left). Only right-moving asteroids collide with left-moving ones. Use a stack:<br><pre><code>def asteroidCollision(asteroids):<br>    stack = []<br>    for ast in asteroids:<br>        alive = True<br>        while alive and stack and ast < 0 < stack[-1]:<br>            if stack[-1] < abs(ast):<br>                stack.pop()       # top asteroid destroyed<br>            elif stack[-1] == abs(ast):<br>                stack.pop()       # both destroyed<br>                alive = False<br>            else:<br>                alive = False     # current destroyed<br>        if alive:<br>            stack.append(ast)<br>    return stack</code></pre><br><b>Time: O(n), Space: O(n)</b>. Collision only occurs when stack top is positive AND current is negative. The while loop handles chain reactions.	stacks_queues::applications
How does BFS use a queue to traverse a tree level by level?	The queue processes nodes in FIFO order, naturally grouping by level. Track level boundaries using the queue's current size:<br><pre><code>from collections import deque<br>def levelOrder(root):<br>    if not root: return []<br>    result = []<br>    queue = deque([root])<br>    while queue:<br>        level_size = len(queue)  # nodes at this level<br>        level = []<br>        for _ in range(level_size):<br>            node = queue.popleft()<br>            level.append(node.val)<br>            if node.left: queue.append(node.left)<br>            if node.right: queue.append(node.right)<br>        result.append(level)<br>    return result</code></pre><br><b>Time: O(n), Space: O(w)</b> where w is max width. The <code>for _ in range(level_size)</code> loop is the key — it processes exactly one level per iteration of the outer while loop.	stacks_queues::applications
How does DFS use a stack (iterative approach)?	Replace the recursion call stack with an explicit stack. Pop a node, process it, push its children:<br><pre><code># Preorder DFS with explicit stack<br>def dfs(root):<br>    if not root: return []<br>    result = []<br>    stack = [root]<br>    while stack:<br>        node = stack.pop()<br>        result.append(node.val)  # process<br>        if node.right: stack.append(node.right)  # right first!<br>        if node.left: stack.append(node.left)<br>    return result</code></pre><br><b>Time: O(n), Space: O(h)</b>. Push right <b>before</b> left so that left is popped first (LIFO). This gives preorder traversal. For postorder, push left before right and reverse the result at the end.	stacks_queues::applications
When should you use a stack vs a queue for graph/tree traversal?	<b>Stack (DFS):</b><br>• Explores as deep as possible before backtracking<br>• Good for: path finding, cycle detection, topological sort, exhaustive search<br>• Uses less memory on wide trees<br><br><b>Queue (BFS):</b><br>• Explores all neighbors at current depth before going deeper<br>• Good for: shortest path (unweighted), level-order traversal, nearest neighbor<br>• Uses less memory on deep/narrow trees<br><br><b>Rule of thumb:</b> Need shortest path or level-by-level? → Queue (BFS). Need to explore all paths or check connectivity? → Stack (DFS).	stacks_queues::applications
What is a monotonic stack and what does "monotonic" mean?	A <b>monotonic stack</b> maintains elements in sorted (monotonically increasing or decreasing) order. When pushing a new element, pop all elements that violate the monotonic property first.<br><br><b>Monotonic increasing:</b> bottom to top is smallest to largest. Pop elements larger than the new one.<br><b>Monotonic decreasing:</b> bottom to top is largest to smallest. Pop elements smaller than the new one.<br><br><b>Key insight:</b> Each element is pushed and popped at most once, so the total work is <b>O(n)</b> even though there's a while loop inside the for loop.	stacks_queues::monotonic
What is the "Next Greater Element" pattern using a monotonic stack?	For each element, find the first element to its right that is larger. Use a <b>monotonic decreasing</b> stack (stores indices):<br><pre><code>def nextGreater(nums):<br>    n = len(nums)<br>    result = [-1] * n<br>    stack = []  # indices, values are decreasing<br>    for i in range(n):<br>        while stack and nums[i] > nums[stack[-1]]:<br>            idx = stack.pop()<br>            result[idx] = nums[i]<br>        stack.append(i)<br>    return result</code></pre><br><b>Time: O(n), Space: O(n)</b>.<br>Example: [2, 1, 3, 5, 4] → [3, 3, 5, -1, -1]<br><br>Elements sitting in the stack are "waiting" for their next greater element. When we find one, we pop and record.	stacks_queues::monotonic
What is the "Next Smaller Element" pattern using a monotonic stack?	Same idea as Next Greater, but use a <b>monotonic increasing</b> stack — pop elements larger than the current one:<br><pre><code>def nextSmaller(nums):<br>    n = len(nums)<br>    result = [-1] * n<br>    stack = []  # indices, values are increasing<br>    for i in range(n):<br>        while stack and nums[i] < nums[stack[-1]]:<br>            idx = stack.pop()<br>            result[idx] = nums[i]<br>        stack.append(i)<br>    return result</code></pre><br><b>Time: O(n), Space: O(n)</b>.<br>Example: [4, 2, 1, 3, 5] → [2, 1, -1, -1, -1]<br><br>The only difference from "next greater" is the comparison operator: <code><</code> instead of <code>></code>.	stacks_queues::monotonic
How do you solve "Daily Temperatures" with a monotonic stack?	For each day, find how many days until a warmer temperature. This is exactly "next greater element" but return the <b>index difference</b>:<br><pre><code>def dailyTemperatures(temps):<br>    n = len(temps)<br>    result = [0] * n<br>    stack = []  # indices of decreasing temps<br>    for i in range(n):<br>        while stack and temps[i] > temps[stack[-1]]:<br>            idx = stack.pop()<br>            result[idx] = i - idx  # days until warmer<br>        stack.append(i)<br>    return result</code></pre><br><b>Time: O(n), Space: O(n)</b>.<br>Example: [73,74,75,71,69,72,76,73] → [1,1,4,2,1,1,0,0]	stacks_queues::monotonic
How do you find the "Largest Rectangle in Histogram" using a monotonic stack?	Maintain a monotonic increasing stack of bar indices. When a shorter bar appears, pop and calculate rectangles:<br><pre><code>def largestRectangle(heights):<br>    stack = []  # indices, heights are increasing<br>    max_area = 0<br>    heights.append(0)  # sentinel to flush stack<br>    for i, h in enumerate(heights):<br>        while stack and heights[stack[-1]] > h:<br>            height = heights[stack.pop()]<br>            width = i if not stack else i - stack[-1] - 1<br>            max_area = max(max_area, height * width)<br>        stack.append(i)<br>    heights.pop()  # remove sentinel<br>    return max_area</code></pre><br><b>Time: O(n), Space: O(n)</b>. When a bar is popped, it means we've found the farthest it can extend left (stack top) and right (current index). The sentinel 0 ensures all bars are eventually processed.	stacks_queues::monotonic
What is a monotonic queue and when do you use it?	A <b>monotonic queue</b> (using a deque) maintains elements in sorted order and supports O(1) access to the current min or max within a sliding window:<br><pre><code>from collections import deque<br>def maxSlidingWindow(nums, k):<br>    dq = deque()  # stores indices, values are decreasing<br>    result = []<br>    for i in range(len(nums)):<br>        # Remove elements outside the window<br>        while dq and dq[0] <= i - k:<br>            dq.popleft()<br>        # Maintain decreasing order<br>        while dq and nums[dq[-1]] <= nums[i]:<br>            dq.pop()<br>        dq.append(i)<br>        if i >= k - 1:<br>            result.append(nums[dq[0]])  # max is always at front<br>    return result</code></pre><br><b>Time: O(n), Space: O(k)</b>. The front of the deque is always the window maximum. Elements smaller than the incoming element are removed from the back (they'll never be the max).	stacks_queues::monotonic
What is the difference between a monotonic stack and a monotonic queue?	<b>Monotonic stack:</b> Elements enter and leave from the <b>same end</b> (top). Used for "next greater/smaller" problems where you look in one direction.<br><br><b>Monotonic queue:</b> Elements enter from <b>one end</b> and can leave from <b>both ends</b> (deque). Used for <b>sliding window</b> problems where old elements expire from the front and dominated elements are removed from the back.<br><br><b>When to use which:</b><br>• "Next greater element" type → monotonic stack<br>• "Maximum/minimum in sliding window" → monotonic queue<br>• Both achieve O(n) by ensuring each element is processed at most twice (push + pop).	stacks_queues::monotonic
How do you solve "Stock Span" problem with a monotonic stack?	The span of a stock price is the number of consecutive days before it (including itself) where the price was ≤ current. Use a monotonic decreasing stack:<br><pre><code>def stockSpan(prices):<br>    result = []<br>    stack = []  # (index) with decreasing prices<br>    for i, price in enumerate(prices):<br>        while stack and prices[stack[-1]] <= price:<br>            stack.pop()<br>        span = i + 1 if not stack else i - stack[-1]<br>        result.append(span)<br>        stack.append(i)<br>    return result</code></pre><br><b>Time: O(n), Space: O(n)</b>. The span equals the distance to the previous greater element (or the start of the array if none exists).	stacks_queues::monotonic
How do you use a stack to convert infix to postfix expression?	Use operator precedence rules. Operands go directly to output; operators go onto the stack following precedence:<br><pre><code>def infixToPostfix(tokens):<br>    prec = {'+':1, '-':1, '*':2, '/':2}<br>    output, stack = [], []<br>    for token in tokens:<br>        if token.isdigit():<br>            output.append(token)<br>        elif token == '(':<br>            stack.append(token)<br>        elif token == ')':<br>            while stack[-1] != '(':<br>                output.append(stack.pop())<br>            stack.pop()  # remove '('<br>        else:  # operator<br>            while stack and stack[-1] != '(' and prec.get(stack[-1],0) >= prec[token]:<br>                output.append(stack.pop())<br>            stack.append(token)<br>    while stack:<br>        output.append(stack.pop())<br>    return output</code></pre><br><b>Time: O(n), Space: O(n)</b>. Known as the <b>Shunting Yard algorithm</b>. Operators with higher or equal precedence on the stack are flushed before pushing the current one.	stacks_queues::applications
How do you use a stack to decode a string like "3[a2[c]]" → "accaccacc"?	Push characters and numbers onto the stack. When hitting <code>]</code>, pop back to the matching <code>[</code>, then multiply the string by the number:<br><pre><code>def decodeString(s):<br>    stack = []<br>    curr_num = 0<br>    curr_str = ""<br>    for char in s:<br>        if char.isdigit():<br>            curr_num = curr_num * 10 + int(char)<br>        elif char == '[':<br>            stack.append((curr_str, curr_num))<br>            curr_str, curr_num = "", 0<br>        elif char == ']':<br>            prev_str, num = stack.pop()<br>            curr_str = prev_str + curr_str * num<br>        else:<br>            curr_str += char<br>    return curr_str</code></pre><br><b>Time: O(n × max_k), Space: O(n)</b>. The stack saves the string-so-far and multiplier before entering each <code>[</code>, then restores and combines them at <code>]</code>.	stacks_queues::applications
How do you remove all adjacent duplicates in a string using a stack?	Push characters onto the stack. If the top matches the current character, pop instead of pushing:<br><pre><code>def removeDuplicates(s):<br>    stack = []<br>    for char in s:<br>        if stack and stack[-1] == char:<br>            stack.pop()<br>        else:<br>            stack.append(char)<br>    return "".join(stack)</code></pre><br><b>Time: O(n), Space: O(n)</b>. Example: "abbaca" → stack trace: [a] → [a,b] → [a] (bb removed) → [a,a] → [] (aa removed) → [c] → [c,a] = "ca".	stacks_queues::applications
How do you find the next greater element in a CIRCULAR array?	Traverse the array twice (simulate circular) using modulo, with a monotonic stack:<br><pre><code>def nextGreaterCircular(nums):<br>    n = len(nums)<br>    result = [-1] * n<br>    stack = []<br>    for i in range(2 * n):  # go around twice<br>        idx = i % n<br>        while stack and nums[idx] > nums[stack[-1]]:<br>            result[stack.pop()] = nums[idx]<br>        if i < n:  # only push indices on first pass<br>            stack.append(idx)<br>    return result</code></pre><br><b>Time: O(n), Space: O(n)</b>. The trick: iterate 0 to 2n-1 using <code>i % n</code> to wrap around. Only push indices during the first pass; the second pass just resolves remaining elements.	stacks_queues::monotonic
How does a stack help simplify file paths like "/a/./b/../../c/"?	Split by "/", use a stack to process each part:<br><pre><code>def simplifyPath(path):<br>    stack = []<br>    for part in path.split("/"):<br>        if part == "..":<br>            if stack: stack.pop()  # go up<br>        elif part and part != ".":<br>            stack.append(part)     # enter directory<br>        # skip empty strings and "."<br>    return "/" + "/".join(stack)</code></pre><br><b>Time: O(n), Space: O(n)</b>. Three cases: <code>".."</code> = go up (pop), <code>"."</code> or empty = skip, anything else = directory name (push). Result: "/c".	stacks_queues::applications
How do you validate a sequence of push/pop operations on a stack?	Simulate the process: push values from the pushed sequence, and pop whenever the top matches the next expected popped value:<br><pre><code>def validateStackSequences(pushed, popped):<br>    stack = []<br>    j = 0<br>    for val in pushed:<br>        stack.append(val)<br>        while stack and stack[-1] == popped[j]:<br>            stack.pop()<br>            j += 1<br>    return j == len(popped)</code></pre><br><b>Time: O(n), Space: O(n)</b>. If we can empty the stack by following both sequences in order, the pop sequence is valid. Each element is pushed once and popped at most once.	stacks_queues::applications
How do you implement "Basic Calculator" (with +, -, and parentheses)?	Use a stack to save the current result and sign when entering parentheses:<br><pre><code>def calculate(s):<br>    stack = []<br>    result, num, sign = 0, 0, 1<br>    for char in s:<br>        if char.isdigit():<br>            num = num * 10 + int(char)<br>        elif char in '+-':<br>            result += sign * num<br>            num = 0<br>            sign = 1 if char == '+' else -1<br>        elif char == '(':<br>            stack.append(result)<br>            stack.append(sign)<br>            result, sign = 0, 1<br>        elif char == ')':<br>            result += sign * num<br>            num = 0<br>            result *= stack.pop()  # sign before paren<br>            result += stack.pop()  # result before paren<br>    return result + sign * num</code></pre><br><b>Time: O(n), Space: O(n)</b>. Parentheses create a "subproblem" — push the outer state, solve inside, then combine.	stacks_queues::applications
What is the "Trapping Rain Water" stack-based approach?	Use a monotonic decreasing stack. When a taller bar appears, pop shorter bars and calculate water trapped between the current bar and the new stack top:<br><pre><code>def trap(height):<br>    stack = []  # indices, heights are decreasing<br>    water = 0<br>    for i, h in enumerate(height):<br>        while stack and height[stack[-1]] < h:<br>            bottom = height[stack.pop()]<br>            if not stack: break<br>            width = i - stack[-1] - 1<br>            bounded = min(h, height[stack[-1]]) - bottom<br>            water += width * bounded<br>        stack.append(i)<br>    return water</code></pre><br><b>Time: O(n), Space: O(n)</b>. This calculates water in horizontal layers, unlike the two-pointer approach which calculates column by column. Both give O(n) time.	stacks_queues::monotonic
What is the "Min Stack" vs "Max Stack" design pattern?	<b>Min Stack:</b> Maintain a parallel stack where each entry is the minimum value seen so far. <code>getMin()</code> = peek the min stack.<br><br><b>Max Stack:</b> Same concept but track maximums. For <code>popMax()</code> (removing the maximum from anywhere), you need a more complex design — typically a <b>doubly linked list + TreeMap/heap</b> combination.<br><br><b>Key insight:</b> Min/Max Stack works because push/pop only affect the top. The min/max at any stack level is either the new value or the previous min/max — a simple comparison.	stacks_queues::applications
What are the key differences between when to use a stack vs a queue in algorithm problems?	<b>Use a STACK when:</b><br>• Processing order is "most recent first" (LIFO)<br>• Matching nested structures (parentheses, HTML tags)<br>• DFS traversal (trees, graphs)<br>• Undo operations<br>• Expression evaluation<br>• Backtracking (implicitly via call stack or explicitly)<br><br><b>Use a QUEUE when:</b><br>• Processing order is "oldest first" (FIFO)<br>• BFS traversal (shortest path, level-order)<br>• Scheduling tasks in order<br>• Sliding window operations (deque)<br>• Buffer/streaming data<br><br><b>Mnemonic:</b> Stack = depth (go deep first). Queue = breadth (go wide first).	stacks_queues::fundamentals
How do you use a stack to track matching pairs (general pattern)?	The stack holds "waiting" items. Each new item either matches the top (pop) or doesn't (push):<br><pre><code># General pattern:<br>stack = []<br>for item in sequence:<br>    if stack and matches(stack[-1], item):<br>        stack.pop()    # matched pair<br>    else:<br>        stack.append(item)  # waiting<br># stack contains all unmatched items</code></pre><br>This pattern applies to: balanced parentheses, removing adjacent duplicates, asteroid collision, and any problem where pairs need to be cancelled. The stack preserves the order needed to identify the correct matching partner.	stacks_queues::applications
What is the "online stock span" pattern using a stack?	Maintain a monotonic decreasing stack of (price, span) pairs. For each new price, pop all prices ≤ current and accumulate their spans:<br><pre><code>class StockSpanner:<br>    def __init__(self):<br>        self.stack = []  # (price, span)<br><br>    def next(self, price):<br>        span = 1<br>        while self.stack and self.stack[-1][0] <= price:<br>            span += self.stack.pop()[1]<br>        self.stack.append((price, span))<br>        return span</code></pre><br><b>Amortized O(1) per call</b>. Each price is pushed once and popped at most once across all calls. The accumulated span includes all consecutive days with prices ≤ current.	stacks_queues::monotonic
How do you implement multi-source BFS with a queue?	Start with ALL sources in the queue at once (instead of a single starting point), then BFS normally. All sources are at distance 0:<br><pre><code>from collections import deque<br>def multiBFS(grid, sources):<br>    queue = deque(sources)  # all sources at once<br>    visited = set(sources)<br>    distance = 0<br>    while queue:<br>        for _ in range(len(queue)):<br>            r, c = queue.popleft()<br>            for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:<br>                nr, nc = r+dr, c+dc<br>                if 0<=nr<rows and 0<=nc<cols and (nr,nc) not in visited:<br>                    visited.add((nr,nc))<br>                    queue.append((nr,nc))<br>        distance += 1</code></pre><br><b>Time: O(m×n), Space: O(m×n)</b>. Used in "Rotting Oranges" (all rotten oranges are sources), "Walls and Gates", and "01 Matrix". The BFS wavefront expands from all sources simultaneously.	stacks_queues::applications
When should you convert recursive DFS to iterative with an explicit stack?	<b>Convert to iterative when:</b><br>• Tree/graph could be very deep (risk of stack overflow)<br>• You need explicit control over traversal order<br>• You want to pause/resume traversal<br>• Space optimization matters (avoid call stack overhead)<br><br><b>Keep recursive when:</b><br>• Code clarity is priority and depth is manageable<br>• The problem naturally uses the call stack (backtracking)<br>• Post-order processing is needed (harder to do iteratively)<br><br><b>Both use O(h) space</b> — recursive uses the call stack implicitly, iterative uses an explicit stack. The space is the same, but iterative avoids Python's ~1000-frame recursion limit.	stacks_queues::fundamentals
