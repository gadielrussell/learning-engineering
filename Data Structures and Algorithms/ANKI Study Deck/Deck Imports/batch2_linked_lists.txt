#separator:Tab
#html:true
#tags column:3
#deck:DSA Master Deck
What is a linked list and how does it differ from an array in memory?	A linked list stores elements in <b>nodes</b> scattered throughout memory. Each node holds data and a pointer to the next node. Unlike arrays (contiguous memory block), linked list nodes can be anywhere in the heap.<br><br><b>Array:</b> <code>[10][20][30][40]</code> — contiguous, index = direct address calculation<br><b>Linked list:</b> <code>[10|→2048] ... [20|→1024] ... [30|→NULL]</code> — nodes linked by pointers<br><br>Key trade-off: Arrays give O(1) random access but O(n) insertion. Linked lists give O(1) insertion at head but O(n) access.	linked_lists::singly::fundamentals
What is the node structure for a singly linked list in Python?	<pre><code>class ListNode:<br>    def __init__(self, val=0, next=None):<br>        self.val = val<br>        self.next = next</code></pre><br>Each node has two fields:<br>• <code>val</code>: the data stored in the node<br>• <code>next</code>: a reference (pointer) to the next node, or <code>None</code> if it's the last node (tail)<br><br>The list itself is typically represented by just a reference to the <b>head</b> node.	linked_lists::singly::fundamentals
What does the head pointer represent in a linked list?	The <b>head</b> is a reference to the first node in the list. It's your only entry point — to reach any node, you must start from the head and traverse forward. If <code>head is None</code>, the list is empty. Losing the head reference means losing access to the entire list.	linked_lists::singly::fundamentals
How do you traverse a singly linked list?	Start at head, follow <code>next</code> pointers until you reach <code>None</code>:<br><pre><code>current = head<br>while current:<br>    print(current.val)  # process node<br>    current = current.next</code></pre><br><b>Time: O(n), Space: O(1)</b>. You must visit nodes sequentially — there's no way to "jump" to a specific index like arrays.	linked_lists::singly::fundamentals
What is the time complexity of inserting at the HEAD of a singly linked list?	<b>O(1)</b>. Create the new node, point it to the current head, then update head:<br><pre><code>def insert_at_head(head, val):<br>    new_node = ListNode(val)<br>    new_node.next = head<br>    return new_node  # new head</code></pre><br>No traversal needed — you only touch the new node and the head pointer.	linked_lists::singly::fundamentals
What is the time complexity of inserting at the TAIL of a singly linked list?	<b>O(n)</b> without a tail pointer, <b>O(1)</b> with one. Without a tail pointer you must traverse the entire list to find the last node:<br><pre><code>def insert_at_tail(head, val):<br>    new_node = ListNode(val)<br>    if not head: return new_node<br>    current = head<br>    while current.next:<br>        current = current.next<br>    current.next = new_node<br>    return head</code></pre><br>Maintaining a separate <code>tail</code> reference avoids the traversal.	linked_lists::singly::fundamentals
How do you insert a node at a specific position in a singly linked list?	Traverse to the node <b>before</b> the insertion point, then rewire pointers:<br><pre><code>def insert_at(head, pos, val):<br>    if pos == 0:<br>        new_node = ListNode(val, head)<br>        return new_node<br>    current = head<br>    for _ in range(pos - 1):<br>        if not current: return head<br>        current = current.next<br>    new_node = ListNode(val)<br>    new_node.next = current.next<br>    current.next = new_node<br>    return head</code></pre><br><b>Time: O(n)</b> to find the position, <b>O(1)</b> for the actual insertion.	linked_lists::singly::fundamentals
How do you delete the HEAD node of a singly linked list?	Simply move the head pointer forward:<br><pre><code>def delete_head(head):<br>    if not head: return None<br>    return head.next  # new head</code></pre><br><b>Time: O(1)</b>. The old head node becomes unreachable and is garbage collected in Python.	linked_lists::singly::fundamentals
How do you delete a node by VALUE in a singly linked list?	Traverse to find the node <b>before</b> the target, then skip over it:<br><pre><code>def delete_value(head, target):<br>    if not head: return None<br>    if head.val == target: return head.next<br>    current = head<br>    while current.next:<br>        if current.next.val == target:<br>            current.next = current.next.next<br>            return head<br>        current = current.next<br>    return head  # not found</code></pre><br><b>Time: O(n)</b>. You need the <b>previous</b> node to rewire, which is why singly linked list deletion requires tracking the predecessor.	linked_lists::singly::fundamentals
How do you delete the TAIL node of a singly linked list?	Traverse to the second-to-last node and set its next to None:<br><pre><code>def delete_tail(head):<br>    if not head or not head.next:<br>        return None<br>    current = head<br>    while current.next.next:<br>        current = current.next<br>    current.next = None<br>    return head</code></pre><br><b>Time: O(n)</b>. You must traverse to find the node before the tail. This is a key disadvantage vs doubly linked lists where tail deletion is O(1).	linked_lists::singly::fundamentals
How do you search for a value in a singly linked list?	Traverse from head, checking each node's value:<br><pre><code>def search(head, target):<br>    current = head<br>    position = 0<br>    while current:<br>        if current.val == target:<br>            return position<br>        current = current.next<br>        position += 1<br>    return -1  # not found</code></pre><br><b>Time: O(n), Space: O(1)</b>. Unlike arrays, there's no binary search shortcut even if data is sorted (no random access).	linked_lists::singly::fundamentals
How do you find the length of a singly linked list?	Count nodes by traversing from head to end:<br><pre><code>def get_length(head):<br>    count = 0<br>    current = head<br>    while current:<br>        count += 1<br>        current = current.next<br>    return count</code></pre><br><b>Time: O(n), Space: O(1)</b>. Unlike arrays which store length as a property, linked lists require a full traversal to count.	linked_lists::singly::fundamentals
Summary: What are the time complexities for all singly linked list operations?	<b>Singly Linked List Time Complexities:</b><br><br>• Access by index: <b>O(n)</b><br>• Search by value: <b>O(n)</b><br>• Insert at head: <b>O(1)</b><br>• Insert at tail (no tail ptr): <b>O(n)</b><br>• Insert at tail (with tail ptr): <b>O(1)</b><br>• Insert at position: <b>O(n)</b><br>• Delete head: <b>O(1)</b><br>• Delete tail: <b>O(n)</b><br>• Delete by value: <b>O(n)</b><br>• Get length: <b>O(n)</b><br><br>Space per node: <b>O(1)</b> — one data field + one pointer.	linked_lists::singly::fundamentals
What is the node structure for a doubly linked list in Python?	<pre><code>class DoublyNode:<br>    def __init__(self, val=0, prev=None, next=None):<br>        self.val = val<br>        self.prev = prev<br>        self.next = next</code></pre><br>Each node has <b>three</b> fields: data, a forward pointer (<code>next</code>), and a backward pointer (<code>prev</code>). This extra pointer costs more memory but enables bidirectional traversal and O(1) deletion when you have a node reference.	linked_lists::doubly::fundamentals
What are the advantages of a doubly linked list over a singly linked list?	<b>1. Bidirectional traversal:</b> Can go both forward and backward.<br><b>2. O(1) deletion with node reference:</b> In a singly list, deleting a node requires the <i>previous</i> node (O(n) to find). In a doubly list, the node itself has a <code>prev</code> pointer.<br><b>3. Tail deletion is O(1):</b> With a tail pointer, just update <code>tail.prev.next = None</code>.<br><b>4. More flexible iteration:</b> Can traverse from either end.<br><br><b>Trade-off:</b> Extra memory per node (one additional pointer) and slightly more complex insert/delete logic (maintaining both prev and next).	linked_lists::doubly::fundamentals
How do you insert at the HEAD of a doubly linked list?	<pre><code>def insert_head(head, val):<br>    new_node = DoublyNode(val)<br>    new_node.next = head<br>    if head:<br>        head.prev = new_node<br>    return new_node  # new head</code></pre><br><b>Time: O(1)</b>. Must update both the new node's <code>next</code> and the old head's <code>prev</code>. If list was empty, the new node becomes both head and tail.	linked_lists::doubly::fundamentals
How do you insert at the TAIL of a doubly linked list (with tail pointer)?	<pre><code>def insert_tail(tail, val):<br>    new_node = DoublyNode(val)<br>    new_node.prev = tail<br>    if tail:<br>        tail.next = new_node<br>    return new_node  # new tail</code></pre><br><b>Time: O(1)</b>. The tail pointer gives direct access — no traversal needed. Update the old tail's <code>next</code> and the new node's <code>prev</code>.	linked_lists::doubly::fundamentals
How do you delete a node in a doubly linked list when you have a reference to it?	Rewire the neighbors to skip the target node:<br><pre><code>def delete_node(node):<br>    if node.prev:<br>        node.prev.next = node.next<br>    if node.next:<br>        node.next.prev = node.prev</code></pre><br><b>Time: O(1)</b> — no traversal needed! This is the key advantage over singly linked lists. You directly access both neighbors via <code>prev</code> and <code>next</code>. Don't forget to update head/tail if the deleted node was at either end.	linked_lists::doubly::fundamentals
When should you use a doubly linked list vs a singly linked list?	<b>Use doubly linked list when:</b><br>• Need bidirectional traversal (browser history, undo/redo)<br>• Need O(1) deletion when you have a node reference (LRU cache)<br>• Need efficient operations at both ends (deque)<br>• Implementing complex data structures (skip lists)<br><br><b>Use singly linked list when:</b><br>• Memory is constrained (saves one pointer per node)<br>• Only need forward traversal<br>• Simple stack/queue implementation<br>• Simpler code is preferred	linked_lists::doubly::fundamentals
How are doubly linked lists used in LRU Cache implementation?	An LRU (Least Recently Used) cache uses a <b>doubly linked list + hash map</b>:<br>• <b>Hash map</b>: key → node reference for O(1) lookup<br>• <b>Doubly linked list</b>: ordered by recency. Most recent at head, least recent at tail.<br><br>On access: move node to head (O(1) with doubly-linked removal + head insertion).<br>On capacity overflow: remove tail node (O(1)).<br><br>Both operations are O(1) because the doubly linked list enables O(1) removal from anywhere + O(1) insertion at head.	linked_lists::doubly::fundamentals
Summary: What are the time complexities for doubly linked list operations?	<b>Doubly Linked List Time Complexities:</b><br><br>• Access by index: <b>O(n)</b><br>• Search by value: <b>O(n)</b><br>• Insert at head: <b>O(1)</b><br>• Insert at tail (with tail ptr): <b>O(1)</b><br>• Insert at position: <b>O(n)</b> to find, <b>O(1)</b> to insert<br>• Delete head: <b>O(1)</b><br>• Delete tail (with tail ptr): <b>O(1)</b><br>• Delete node (with reference): <b>O(1)</b> ← key advantage<br>• Delete by value: <b>O(n)</b> to find<br>• Traverse forward or backward: <b>O(n)</b><br><br>Space per node: <b>O(1)</b> — one data field + two pointers.	linked_lists::doubly::fundamentals
What is the dummy/sentinel node technique and why is it useful?	A <b>dummy node</b> is a fake node placed before the actual head. You initialize it and build the list after it, then return <code>dummy.next</code> as the real head.<br><pre><code>dummy = ListNode(0)  # sentinel<br>current = dummy<br># ... build or modify list using current ...<br>return dummy.next  # real head</code></pre><br><b>Why it's useful:</b><br>• Eliminates special-case logic for empty lists and head modifications<br>• The head might change (deletion, insertion) — dummy provides a stable anchor<br>• Simplifies merge operations where you don't know which node comes first<br><br>Use it whenever the head of the result list is unknown or may change.	linked_lists::patterns
When should you use a dummy node in linked list problems?	Use a dummy node when:<br><b>1.</b> The head might be removed (e.g., "remove all nodes with value X")<br><b>2.</b> You're building a new list and don't know the first element yet (e.g., merge two sorted lists)<br><b>3.</b> The head might change during the operation<br><b>4.</b> You want to avoid separate <code>if not head</code> checks<br><br><b>Pattern:</b><br><pre><code>dummy = ListNode(0)<br>tail = dummy        # tail builds the result<br># ... append nodes to tail ...<br>tail.next = node<br>tail = tail.next<br>return dummy.next   # skip the dummy</code></pre>	linked_lists::patterns
What is the fast/slow pointer (tortoise and hare) technique?	Two pointers traverse the list at different speeds: <code>slow</code> moves 1 step, <code>fast</code> moves 2 steps per iteration:<br><pre><code>slow = fast = head<br>while fast and fast.next:<br>    slow = slow.next<br>    fast = fast.next.next</code></pre><br><b>When fast reaches the end, slow is at the middle.</b><br><br>Uses:<br>• Find the middle node<br>• Detect cycles (Floyd's algorithm)<br>• Find the start of a cycle<br>• Split list into two halves<br><br>The condition <code>fast and fast.next</code> handles both even and odd length lists.	linked_lists::patterns
How does the fast/slow pointer find the middle of a linked list?	Fast moves 2x speed, so when fast reaches the end, slow is at the midpoint:<br><pre><code>def findMiddle(head):<br>    slow = fast = head<br>    while fast and fast.next:<br>        slow = slow.next<br>        fast = fast.next.next<br>    return slow</code></pre><br><b>Odd length [1→2→3→4→5]:</b> slow lands on 3 (exact middle)<br><b>Even length [1→2→3→4]:</b> slow lands on 3 (start of second half)<br><br><b>Time: O(n), Space: O(1)</b>. For even-length lists, if you need the end of the first half (node 2), use <code>while fast.next and fast.next.next</code> instead.	linked_lists::patterns
How does Floyd's algorithm detect a cycle in a linked list?	If there's a cycle, a fast pointer (2 steps) will eventually "lap" a slow pointer (1 step) and they'll meet inside the cycle:<br><pre><code>def hasCycle(head):<br>    slow = fast = head<br>    while fast and fast.next:<br>        slow = slow.next<br>        fast = fast.next.next<br>        if slow == fast:<br>            return True<br>    return False</code></pre><br><b>Time: O(n), Space: O(1)</b>.<br><br><b>Why they must meet:</b> Once both are in the cycle, the fast pointer closes the gap by 1 node each iteration. They're guaranteed to collide within one full cycle length.	linked_lists::patterns
How do you find the START of a cycle in a linked list?	After detecting the meeting point with Floyd's algorithm, reset one pointer to head. Move both pointers at speed 1 — they'll meet at the cycle start:<br><pre><code>def detectCycleStart(head):<br>    slow = fast = head<br>    while fast and fast.next:<br>        slow = slow.next<br>        fast = fast.next.next<br>        if slow == fast:<br>            # Reset one pointer to head<br>            slow = head<br>            while slow != fast:<br>                slow = slow.next<br>                fast = fast.next<br>            return slow  # cycle start<br>    return None</code></pre><br><b>Time: O(n), Space: O(1)</b>. This works because of a mathematical property: the distance from head to cycle start equals the distance from meeting point to cycle start (traveling around the cycle).	linked_lists::patterns
How do you use two pointers to find the Nth node from the end?	Advance the first pointer N steps ahead, then move both pointers together. When the first reaches the end, the second is at the Nth from end:<br><pre><code>def nthFromEnd(head, n):<br>    first = second = head<br>    for _ in range(n):<br>        first = first.next<br>    while first:<br>        first = first.next<br>        second = second.next<br>    return second</code></pre><br><b>Time: O(n), Space: O(1)</b>. The gap of N nodes between the two pointers is maintained throughout. When <code>first</code> hits <code>None</code>, <code>second</code> is exactly N nodes from the end.	linked_lists::patterns
What is the "runner" technique for linked lists?	The runner technique uses two pointers at different speeds to solve problems that need information about relative positions. It's essentially the fast/slow pointer pattern applied broadly:<br><br><b>Common applications:</b><br>• <b>Find middle:</b> fast=2x, slow=1x → slow at middle<br>• <b>Interleave:</b> split at middle, then weave together<br>• <b>Palindrome check:</b> find middle, reverse second half, compare<br>• <b>Cycle detection:</b> fast catches slow if cycle exists<br><br>The key insight: by moving at different speeds, you create a known relationship between the two positions without needing the list length.	linked_lists::patterns
How do you reverse a singly linked list iteratively?	Track three pointers: <code>prev</code>, <code>curr</code>, and <code>next</code>. Reverse each link one at a time:<br><pre><code>def reverseList(head):<br>    prev = None<br>    curr = head<br>    while curr:<br>        nxt = curr.next    # save next<br>        curr.next = prev   # reverse link<br>        prev = curr        # advance prev<br>        curr = nxt         # advance curr<br>    return prev  # new head</code></pre><br><b>Time: O(n), Space: O(1)</b>.<br><br>Trace: <code>1→2→3→None</code><br>Step 1: <code>None←1  2→3→None</code><br>Step 2: <code>None←1←2  3→None</code><br>Step 3: <code>None←1←2←3</code> → return 3 (new head)	linked_lists::algorithms
How do you reverse a singly linked list recursively?	The recursive approach reverses from the tail backward:<br><pre><code>def reverseList(head):<br>    if not head or not head.next:<br>        return head  # base case: empty or single node<br>    new_head = reverseList(head.next)  # recurse to end<br>    head.next.next = head  # reverse the link<br>    head.next = None       # break forward link<br>    return new_head</code></pre><br><b>Time: O(n), Space: O(n)</b> due to call stack.<br><br>The recursion goes down to the last node (new head), then as it unwinds, each node makes its <code>next</code> node point back to it. <code>head.next.next = head</code> is the key line — it says "my next node should point back to me."	linked_lists::algorithms
How do you merge two sorted linked lists?	Use a dummy node and compare values, appending the smaller node each time:<br><pre><code>def mergeTwoLists(l1, l2):<br>    dummy = ListNode(0)<br>    current = dummy<br>    while l1 and l2:<br>        if l1.val <= l2.val:<br>            current.next = l1<br>            l1 = l1.next<br>        else:<br>            current.next = l2<br>            l2 = l2.next<br>        current = current.next<br>    current.next = l1 or l2  # attach remaining<br>    return dummy.next</code></pre><br><b>Time: O(n + m), Space: O(1)</b>. The dummy node eliminates edge cases about which list's first node is smaller. <code>l1 or l2</code> attaches whichever list has remaining nodes.	linked_lists::algorithms
How do you check if a linked list is a palindrome?	<b>Three steps:</b> Find middle → Reverse second half → Compare both halves:<br><pre><code>def isPalindrome(head):<br>    # 1. Find middle with fast/slow<br>    slow = fast = head<br>    while fast and fast.next:<br>        slow = slow.next<br>        fast = fast.next.next<br>    # 2. Reverse second half<br>    prev = None<br>    curr = slow<br>    while curr:<br>        nxt = curr.next<br>        curr.next = prev<br>        prev = curr<br>        curr = nxt<br>    # 3. Compare first and reversed second half<br>    left, right = head, prev<br>    while right:<br>        if left.val != right.val:<br>            return False<br>        left = left.next<br>        right = right.next<br>    return True</code></pre><br><b>Time: O(n), Space: O(1)</b>. Combines three patterns: fast/slow pointer, list reversal, and two-pointer comparison.	linked_lists::algorithms
How do you find the intersection point of two linked lists?	Calculate length difference, advance the longer list's pointer by that difference, then walk both together:<br><pre><code>def getIntersectionNode(headA, headB):<br>    # Elegant approach: switch heads<br>    a, b = headA, headB<br>    while a != b:<br>        a = a.next if a else headB<br>        b = b.next if b else headA<br>    return a  # intersection or None</code></pre><br><b>Time: O(n + m), Space: O(1)</b>.<br><br><b>Why this works:</b> Pointer A traverses list A then list B. Pointer B traverses list B then list A. Both travel the same total distance (lenA + lenB), so they align at the intersection. If no intersection, both reach <code>None</code> simultaneously.	linked_lists::algorithms
How do you remove the Nth node from the end of a linked list?	Use the two-pointer gap technique with a dummy node to handle edge cases:<br><pre><code>def removeNthFromEnd(head, n):<br>    dummy = ListNode(0, head)<br>    first = second = dummy<br>    for _ in range(n + 1):  # n+1 gap so second stops BEFORE target<br>        first = first.next<br>    while first:<br>        first = first.next<br>        second = second.next<br>    second.next = second.next.next  # skip the target<br>    return dummy.next</code></pre><br><b>Time: O(n), Space: O(1)</b>. The dummy node handles the edge case where you need to remove the head itself. The <code>n+1</code> gap ensures <code>second</code> stops one node before the target.	linked_lists::algorithms
What is the "reorder list" pattern (L0→Ln→L1→Ln-1→...)?	Three steps: find middle, reverse second half, interleave (merge alternating):<br><pre><code>def reorderList(head):<br>    # 1. Find middle<br>    slow = fast = head<br>    while fast.next and fast.next.next:<br>        slow = slow.next<br>        fast = fast.next.next<br>    # 2. Reverse second half<br>    prev, curr = None, slow.next<br>    slow.next = None  # split the list<br>    while curr:<br>        nxt = curr.next<br>        curr.next = prev<br>        prev = curr<br>        curr = nxt<br>    # 3. Merge alternating<br>    first, second = head, prev<br>    while second:<br>        tmp1, tmp2 = first.next, second.next<br>        first.next = second<br>        second.next = tmp1<br>        first, second = tmp1, tmp2</code></pre><br><b>Time: O(n), Space: O(1)</b>. Combines find-middle, reversal, and merge — three core linked list operations in one problem.	linked_lists::algorithms
How do you sort a linked list efficiently?	Use <b>merge sort</b> — it's ideal for linked lists because merging is O(1) space (just pointer rewiring):<br><pre><code>def sortList(head):<br>    if not head or not head.next:<br>        return head<br>    # Split: find middle<br>    slow, fast = head, head.next<br>    while fast and fast.next:<br>        slow = slow.next<br>        fast = fast.next.next<br>    mid = slow.next<br>    slow.next = None  # cut<br>    # Recurse on both halves<br>    left = sortList(head)<br>    right = sortList(mid)<br>    # Merge sorted halves<br>    return mergeTwoLists(left, right)</code></pre><br><b>Time: O(n log n), Space: O(log n)</b> for recursion stack. Quick sort is poor on linked lists due to lack of random access for pivot selection.	linked_lists::algorithms
How do you add two numbers represented as linked lists (digits in reverse order)?	Simulate addition digit by digit with a carry:<br><pre><code>def addTwoNumbers(l1, l2):<br>    dummy = ListNode(0)<br>    current = dummy<br>    carry = 0<br>    while l1 or l2 or carry:<br>        val = carry<br>        if l1: val += l1.val; l1 = l1.next<br>        if l2: val += l2.val; l2 = l2.next<br>        carry = val // 10<br>        current.next = ListNode(val % 10)<br>        current = current.next<br>    return dummy.next</code></pre><br><b>Time: O(max(n,m)), Space: O(max(n,m))</b>. The dummy node simplifies building the result. The <code>or carry</code> in the while condition handles the case where the final sum creates an extra digit (e.g., 99 + 1 = 100).	linked_lists::algorithms
How do you deep copy a linked list with random pointers?	Use a hash map to map old nodes → new copies, then wire up next and random:<br><pre><code>def copyRandomList(head):<br>    if not head: return None<br>    # Pass 1: Create copies in a map<br>    old_to_new = {}<br>    curr = head<br>    while curr:<br>        old_to_new[curr] = Node(curr.val)<br>        curr = curr.next<br>    # Pass 2: Wire up next and random pointers<br>    curr = head<br>    while curr:<br>        old_to_new[curr].next = old_to_new.get(curr.next)<br>        old_to_new[curr].random = old_to_new.get(curr.random)<br>        curr = curr.next<br>    return old_to_new[head]</code></pre><br><b>Time: O(n), Space: O(n)</b>. The map ensures each node is copied exactly once. <code>.get()</code> handles None values gracefully.	linked_lists::algorithms
How do you reverse a linked list between positions left and right (reverse sublist)?	Traverse to the node before <code>left</code>, then reverse the sublist in place:<br><pre><code>def reverseBetween(head, left, right):<br>    dummy = ListNode(0, head)<br>    prev = dummy<br>    for _ in range(left - 1):<br>        prev = prev.next<br>    # Reverse 'right - left' connections<br>    curr = prev.next<br>    for _ in range(right - left):<br>        nxt = curr.next<br>        curr.next = nxt.next<br>        nxt.next = prev.next<br>        prev.next = nxt<br>    return dummy.next</code></pre><br><b>Time: O(n), Space: O(1)</b>. The dummy node handles the case where <code>left = 1</code> (reversing from the head). Each iteration moves the next node to the front of the reversed section.	linked_lists::algorithms
How do you swap nodes in pairs in a linked list?	Use a dummy node and swap every two adjacent nodes by rewiring pointers:<br><pre><code>def swapPairs(head):<br>    dummy = ListNode(0, head)<br>    prev = dummy<br>    while prev.next and prev.next.next:<br>        first = prev.next<br>        second = prev.next.next<br>        # Swap<br>        first.next = second.next<br>        second.next = first<br>        prev.next = second<br>        # Advance<br>        prev = first<br>    return dummy.next</code></pre><br><b>Time: O(n), Space: O(1)</b>. For each pair: <code>prev→A→B→C</code> becomes <code>prev→B→A→C</code>. Then <code>prev</code> advances to <code>A</code> (which is now second in the pair).	linked_lists::algorithms
How do you remove all nodes with a given value from a linked list?	Use a dummy node to handle the case where the head itself needs removal:<br><pre><code>def removeElements(head, val):<br>    dummy = ListNode(0, head)<br>    current = dummy<br>    while current.next:<br>        if current.next.val == val:<br>            current.next = current.next.next<br>        else:<br>            current = current.next<br>    return dummy.next</code></pre><br><b>Time: O(n), Space: O(1)</b>. Key detail: only advance <code>current</code> when you do NOT delete, because after deletion <code>current.next</code> is already the next node to check (it might also need removal).	linked_lists::algorithms
How do you detect if a linked list has a cycle using O(1) space? Why does Floyd's work?	Floyd's cycle detection uses fast (2 steps) and slow (1 step) pointers:<br><pre><code>slow = fast = head<br>while fast and fast.next:<br>    slow = slow.next<br>    fast = fast.next.next<br>    if slow == fast: return True<br>return False</code></pre><br><b>Why it works mathematically:</b> If there's a cycle of length C, once both pointers are in the cycle, the fast pointer closes the gap by 1 node each iteration (speed difference = 2-1 = 1). So they must meet within C iterations.<br><br><b>Alternative:</b> Hash set of visited nodes — O(n) space. Floyd's is preferred because it's O(1) space.	linked_lists::algorithms
How do you split a linked list into two halves?	Use fast/slow pointers to find the middle, then cut:<br><pre><code>def splitList(head):<br>    if not head or not head.next:<br>        return head, None<br>    slow, fast = head, head.next<br>    while fast and fast.next:<br>        slow = slow.next<br>        fast = fast.next.next<br>    second_half = slow.next<br>    slow.next = None  # cut the list<br>    return head, second_half</code></pre><br><b>Time: O(n), Space: O(1)</b>. Using <code>fast = head.next</code> ensures that for even-length lists, <code>slow</code> ends at the last node of the first half (giving equal or first-half-smaller split).	linked_lists::algorithms
How do you rotate a linked list by k positions to the right?	Make it circular, then cut at the right spot:<br><pre><code>def rotateRight(head, k):<br>    if not head or not head.next or k == 0:<br>        return head<br>    # Find length and tail<br>    length = 1<br>    tail = head<br>    while tail.next:<br>        tail = tail.next<br>        length += 1<br>    # Make circular<br>    tail.next = head<br>    # Find new tail (length - k%length - 1 steps from head)<br>    steps = length - (k % length)<br>    new_tail = head<br>    for _ in range(steps - 1):<br>        new_tail = new_tail.next<br>    new_head = new_tail.next<br>    new_tail.next = None  # break circle<br>    return new_head</code></pre><br><b>Time: O(n), Space: O(1)</b>. The <code>k % length</code> handles k larger than the list length.	linked_lists::algorithms
How do you partition a linked list around a value x?	Create two separate lists (less-than and greater-or-equal), then connect them:<br><pre><code>def partition(head, x):<br>    before_dummy = ListNode(0)<br>    after_dummy = ListNode(0)<br>    before = before_dummy<br>    after = after_dummy<br>    while head:<br>        if head.val < x:<br>            before.next = head<br>            before = before.next<br>        else:<br>            after.next = head<br>            after = after.next<br>        head = head.next<br>    after.next = None  # important: terminate<br>    before.next = after_dummy.next  # connect lists<br>    return before_dummy.next</code></pre><br><b>Time: O(n), Space: O(1)</b>. Two dummy nodes make this clean. Critical: set <code>after.next = None</code> to avoid cycles from the original list's pointers.	linked_lists::algorithms
How do you remove duplicates from a SORTED linked list?	Compare each node with its next neighbor and skip duplicates:<br><pre><code>def deleteDuplicates(head):<br>    current = head<br>    while current and current.next:<br>        if current.val == current.next.val:<br>            current.next = current.next.next<br>        else:<br>            current = current.next<br>    return head</code></pre><br><b>Time: O(n), Space: O(1)</b>. Only advance when values differ — the next node after deletion might also be a duplicate. Since the list is sorted, all duplicates are adjacent.	linked_lists::algorithms
How do you remove ALL duplicates from a sorted linked list (keep zero copies)?	Use a dummy node because the head itself might be a duplicate:<br><pre><code>def deleteDuplicates(head):<br>    dummy = ListNode(0, head)<br>    prev = dummy<br>    curr = head<br>    while curr:<br>        # Skip all nodes with same value<br>        if curr.next and curr.val == curr.next.val:<br>            while curr.next and curr.val == curr.next.val:<br>                curr = curr.next<br>            prev.next = curr.next  # skip ALL dupes<br>        else:<br>            prev = curr<br>        curr = curr.next<br>    return dummy.next</code></pre><br><b>Time: O(n), Space: O(1)</b>. The inner while loop skips all copies of the duplicated value. <code>prev</code> stays anchored at the last confirmed unique node.	linked_lists::algorithms
How do you find the middle node and what happens with even-length lists?	<pre><code>slow = fast = head<br>while fast and fast.next:<br>    slow = slow.next<br>    fast = fast.next.next<br># slow is now at middle</code></pre><br><b>Odd [1→2→3→4→5]:</b> slow = 3 (exact middle)<br><b>Even [1→2→3→4]:</b> slow = 3 (second of two middle nodes)<br><br>If you need the <b>first</b> middle node for even-length lists (node 2 above), use:<br><pre><code>slow = fast = head<br>while fast.next and fast.next.next:<br>    slow = slow.next<br>    fast = fast.next.next</code></pre><br>This matters for palindrome checks and splitting — you often want the end of the first half.	linked_lists::patterns
What are the common edge cases to handle in linked list problems?	<b>Always check these:</b><br>1. <b>Empty list:</b> <code>head is None</code><br>2. <b>Single node:</b> <code>head.next is None</code><br>3. <b>Two nodes:</b> Many pointer operations need at least 2-3 nodes<br>4. <b>Cycle present:</b> <code>while current</code> loops infinitely<br>5. <b>Head changes:</b> Use a dummy node when the head might be removed or replaced<br>6. <b>Null pointer dereference:</b> Always check <code>node is not None</code> before accessing <code>node.next</code> or <code>node.val</code><br>7. <b>Not terminating the list:</b> After modifications, ensure the last node's <code>next</code> is <code>None</code> to prevent cycles	linked_lists::patterns
What are the three essential linked list reversal variations you should know?	<b>1. Full reversal (iterative):</b><br><code>prev=None, curr=head → reverse all links → return prev</code><br><br><b>2. Full reversal (recursive):</b><br><code>recurse to end → head.next.next = head → head.next = None → return new_head</code><br><br><b>3. Partial reversal (between positions):</b><br><code>find node before start → reverse sublist in place → reconnect ends</code><br><br>All use the same core operation: for each node, save next, redirect current's pointer backward, advance. The difference is where you start, stop, and how you reconnect.	linked_lists::algorithms
What is the pattern for merging k sorted linked lists?	Use a <b>min-heap</b> to always pick the smallest available node:<br><pre><code>import heapq<br>def mergeKLists(lists):<br>    dummy = ListNode(0)<br>    current = dummy<br>    heap = []<br>    for i, lst in enumerate(lists):<br>        if lst:<br>            heapq.heappush(heap, (lst.val, i, lst))<br>    while heap:<br>        val, i, node = heapq.heappop(heap)<br>        current.next = node<br>        current = current.next<br>        if node.next:<br>            heapq.heappush(heap, (node.next.val, i, node.next))<br>    return dummy.next</code></pre><br><b>Time: O(N log k)</b> where N = total nodes, k = number of lists. The heap always has at most k elements. The index <code>i</code> is used as a tiebreaker since ListNode isn't comparable.	linked_lists::algorithms
How do you reverse nodes in groups of k (reverse k-group)?	Check if k nodes remain, reverse that group, then recurse/iterate for the next group:<br><pre><code>def reverseKGroup(head, k):<br>    # Check if k nodes available<br>    count = 0<br>    curr = head<br>    while curr and count < k:<br>        curr = curr.next<br>        count += 1<br>    if count < k: return head  # not enough nodes<br>    # Reverse k nodes<br>    prev, curr = None, head<br>    for _ in range(k):<br>        nxt = curr.next<br>        curr.next = prev<br>        prev = curr<br>        curr = nxt<br>    # head is now the tail of reversed group<br>    head.next = reverseKGroup(curr, k)<br>    return prev  # new head of this group</code></pre><br><b>Time: O(n), Space: O(n/k)</b> for recursion. After reversing, the original <code>head</code> becomes the tail of the group and connects to the result of the next group.	linked_lists::algorithms
What is the "weave" or "interleave" pattern for linked lists?	Alternately connect nodes from two lists:<br><pre><code>def interleave(l1, l2):<br>    while l1 and l2:<br>        l1_next = l1.next<br>        l2_next = l2.next<br>        l1.next = l2<br>        l2.next = l1_next<br>        l1 = l1_next<br>        l2 = l2_next</code></pre><br><b>Result:</b> <code>l1[0]→l2[0]→l1[1]→l2[1]→...</code><br><br><b>Time: O(n), Space: O(1)</b>. Used in the "reorder list" problem after splitting and reversing. Key: save both <code>.next</code> pointers BEFORE rewiring, or you'll lose access to the rest of the lists.	linked_lists::algorithms
How do you detect if two linked lists intersect?	Two approaches:<br><br><b>1. Length difference (explicit):</b> Find both lengths, advance the longer list by the difference, then walk together.<br><br><b>2. Pointer switching (elegant):</b><br><pre><code>def getIntersection(headA, headB):<br>    a, b = headA, headB<br>    while a != b:<br>        a = a.next if a else headB<br>        b = b.next if b else headA<br>    return a</code></pre><br><b>Why switching works:</b> If list A has length 5 and list B has length 3, pointer A travels 5+3=8 steps and pointer B travels 3+5=8 steps. They "sync up" at the intersection point. If no intersection, both reach <code>None</code> at the same time.	linked_lists::algorithms
What is the odd-even linked list rearrangement pattern?	Group all odd-indexed nodes first, then all even-indexed nodes:<br><pre><code>def oddEvenList(head):<br>    if not head: return head<br>    odd = head<br>    even = head.next<br>    even_head = even  # save even list head<br>    while even and even.next:<br>        odd.next = even.next<br>        odd = odd.next<br>        even.next = odd.next<br>        even = even.next<br>    odd.next = even_head  # connect odd tail to even head<br>    return head</code></pre><br><b>Time: O(n), Space: O(1)</b>. Two pointers build separate odd and even chains simultaneously, then connect them. Preserves relative order within each group.	linked_lists::algorithms
How do you flatten a multilevel doubly linked list?	Use DFS — when you encounter a child, splice the child chain into the main list:<br><pre><code>def flatten(head):<br>    curr = head<br>    while curr:<br>        if curr.child:<br>            # Find tail of child list<br>            child_tail = curr.child<br>            while child_tail.next:<br>                child_tail = child_tail.next<br>            # Splice child between curr and curr.next<br>            child_tail.next = curr.next<br>            if curr.next:<br>                curr.next.prev = child_tail<br>            curr.next = curr.child<br>            curr.child.prev = curr<br>            curr.child = None<br>        curr = curr.next<br>    return head</code></pre><br><b>Time: O(n), Space: O(1)</b>. Process children as you encounter them — previously spliced children are naturally handled when you continue traversing forward.	linked_lists::algorithms
What is the key insight for choosing between singly vs doubly linked list in algorithm problems?	<b>Use singly when:</b> The problem only requires forward traversal, or you're told it's singly linked. Most interview problems use singly linked lists.<br><br><b>Use doubly when:</b> You need to delete a node given only a reference to it (O(1) vs O(n)), implement a deque or LRU cache, or traverse backward.<br><br><b>Key interview insight:</b> If a problem requires O(1) deletion AND O(1) lookup, think <b>hash map + doubly linked list</b> (the LRU cache pattern). The hash map gives O(1) lookup, and the doubly linked list gives O(1) removal and insertion.	linked_lists::patterns
What is the general strategy for approaching linked list problems in interviews?	<b>Step-by-step approach:</b><br><br>1. <b>Clarify:</b> Singly or doubly? Sorted? Cycles possible? Can I modify the list?<br><br>2. <b>Consider these tools:</b><br>• Dummy node — if head might change<br>• Fast/slow pointers — if you need middle, cycle detection, or relative positioning<br>• Reversal — if comparing halves, reordering, or need backward access<br>• Multiple passes — first to gather info (length), second to act<br><br>3. <b>Draw it out:</b> Sketch 3-5 nodes, draw pointer changes step by step<br><br>4. <b>Check edge cases:</b> Empty list, single node, two nodes, cycle<br><br>5. <b>Common red flags:</b><br>• Forgetting to save <code>.next</code> before rewiring<br>• Not terminating the list (causing cycles)<br>• Off-by-one on positions	linked_lists::patterns
