#separator:Tab
#html:true
#tags column:3
#deck:DSA Master Deck
What is a graph and what are its core components?	A <b>graph</b> G = (V, E) consists of:<br>• <b>Vertices (V):</b> The nodes/points<br>• <b>Edges (E):</b> Connections between vertices<br><br><b>Types:</b><br>• <b>Directed:</b> Edges have direction (A → B ≠ B → A). Example: web links, dependencies.<br>• <b>Undirected:</b> Edges are bidirectional (A — B). Example: friendships, roads.<br>• <b>Weighted:</b> Edges have costs/distances. Example: maps, network latency.<br>• <b>Unweighted:</b> All edges have equal cost.<br><br>Graphs can also be <b>cyclic</b> (contain loops) or <b>acyclic</b> (no loops). A directed acyclic graph (DAG) is especially important for scheduling and dependency problems.	graphs::fundamentals
What is the difference between an adjacency list and an adjacency matrix?	<b>Adjacency List:</b> Each vertex stores a list of its neighbors.<br><pre><code># Dict of lists<br>graph = {<br>    0: [1, 2],<br>    1: [0, 3],<br>    2: [0],<br>    3: [1]<br>}</code></pre><br>Space: <b>O(V + E)</b>. Best for <b>sparse</b> graphs (few edges).<br><br><b>Adjacency Matrix:</b> 2D array where <code>matrix[i][j] = 1</code> if edge exists.<br><pre><code>matrix = [<br>    [0, 1, 1, 0],<br>    [1, 0, 0, 1],<br>    [1, 0, 0, 0],<br>    [0, 1, 0, 0]<br>]</code></pre><br>Space: <b>O(V²)</b>. Best for <b>dense</b> graphs or when you need O(1) edge lookup.<br><br>Most interview problems use adjacency lists because real-world graphs are sparse.	graphs::fundamentals
How do you build an adjacency list from an edge list in Python?	<pre><code>from collections import defaultdict<br><br># Undirected graph<br>edges = [[0,1], [0,2], [1,3]]<br>graph = defaultdict(list)<br>for u, v in edges:<br>    graph[u].append(v)<br>    graph[v].append(u)  # remove for directed<br><br># Weighted graph<br>weighted_edges = [[0,1,5], [0,2,3]]  # [from, to, weight]<br>graph = defaultdict(list)<br>for u, v, w in weighted_edges:<br>    graph[u].append((v, w))<br>    graph[v].append((u, w))</code></pre><br><b>Time: O(E)</b> to build. <code>defaultdict(list)</code> avoids KeyError for new vertices. For directed graphs, only add one direction. Always clarify: directed or undirected? weighted or unweighted?	graphs::fundamentals
What are the key graph terms: degree, path, cycle, connected, component?	<b>Degree:</b> Number of edges connected to a vertex. In directed graphs: in-degree (incoming) + out-degree (outgoing).<br><br><b>Path:</b> A sequence of vertices where each consecutive pair has an edge.<br><br><b>Cycle:</b> A path that starts and ends at the same vertex.<br><br><b>Connected:</b> An undirected graph where every vertex can reach every other vertex. For directed: <b>strongly connected</b> = every vertex reachable from every other.<br><br><b>Connected component:</b> A maximal subgraph where all vertices are connected to each other. "Number of islands" = number of connected components.<br><br><b>DAG:</b> Directed Acyclic Graph — has directed edges but no cycles. Used for scheduling, dependency resolution.	graphs::fundamentals
How does BFS work on a graph?	BFS explores <b>level by level</b> using a queue — all neighbors at distance d before distance d+1:<br><pre><code>from collections import deque<br>def bfs(graph, start):<br>    visited = {start}<br>    queue = deque([start])<br>    while queue:<br>        node = queue.popleft()<br>        for neighbor in graph[node]:<br>            if neighbor not in visited:<br>                visited.add(neighbor)<br>                queue.append(neighbor)</code></pre><br><b>Time: O(V + E), Space: O(V)</b>.<br><br><b>Key properties:</b><br>• Finds <b>shortest path</b> in unweighted graphs<br>• Visits nodes in order of increasing distance<br>• Add to visited <b>when enqueueing</b>, not when dequeueing (prevents duplicates in queue)	graphs::traversals
How does DFS work on a graph (recursive and iterative)?	DFS explores <b>as deep as possible</b> before backtracking:<br><br><b>Recursive:</b><br><pre><code>def dfs(graph, node, visited):<br>    visited.add(node)<br>    for neighbor in graph[node]:<br>        if neighbor not in visited:<br>            dfs(graph, neighbor, visited)</code></pre><br><b>Iterative (stack):</b><br><pre><code>def dfs(graph, start):<br>    visited = set()<br>    stack = [start]<br>    while stack:<br>        node = stack.pop()<br>        if node in visited: continue<br>        visited.add(node)<br>        for neighbor in graph[node]:<br>            if neighbor not in visited:<br>                stack.append(neighbor)</code></pre><br><b>Time: O(V + E), Space: O(V)</b>. Note: iterative DFS checks visited <b>after popping</b> (may have duplicates in stack), unlike BFS which checks <b>before enqueueing</b>.	graphs::traversals
When should you use BFS vs DFS on graphs?	<b>Use BFS when:</b><br>• Finding <b>shortest path</b> (unweighted graphs)<br>• Level-order / layer-by-layer processing<br>• Finding nearest matching node<br>• Multi-source problems (start BFS from all sources at once)<br><br><b>Use DFS when:</b><br>• Finding <b>connected components</b><br>• Detecting <b>cycles</b><br>• <b>Topological sort</b><br>• Exploring <b>all paths</b> / exhaustive search<br>• Backtracking problems<br>• Checking if a path exists (don't need shortest)<br><br><b>Both work for:</b> Counting components, checking connectivity, visiting all nodes. Choose based on what <b>extra information</b> you need (shortest distance → BFS, path tracking → DFS).	graphs::traversals
What is the key insight: "A matrix is a graph in disguise"?	Every cell in a matrix is a <b>node</b>, and adjacency (up/down/left/right) defines <b>edges</b>. Matrix problems are graph problems with implicit spatial edges:<br><pre><code># Matrix view:       Graph view:<br>#  1  0  1          (0,0)---(0,2)<br>#  1  1  0            |       <br>#  0  1  1          (1,0)--(1,1)<br>#                           |<br>#                    (2,1)--(2,2)</code></pre><br>This reframing means <b>all graph algorithms apply</b> to matrices — BFS, DFS, Union-Find, etc. The matrix structure gives extra properties: coordinates, boundaries, spatial locality.<br><br><b>Edges</b> are defined by the direction array: <code>[(0,1),(0,-1),(1,0),(-1,0)]</code>. For 8-directional problems, add the diagonals.	graphs::matrix_as_graph
What is the direction array pattern for matrix traversal?	The direction array encodes neighbor relationships as (row_delta, col_delta):<br><pre><code># 4-directional (standard)<br>directions = [(0,1), (0,-1), (1,0), (-1,0)]<br><br># 8-directional (includes diagonals)<br>directions = [(0,1),(0,-1),(1,0),(-1,0),(1,1),(1,-1),(-1,1),(-1,-1)]<br><br># Usage:<br>for dr, dc in directions:<br>    nr, nc = r + dr, c + dc<br>    if 0 <= nr < rows and 0 <= nc < cols:<br>        # process (nr, nc)</code></pre><br><b>Bounds check:</b> <code>0 <= nr < rows and 0 <= nc < cols</code> replaces checking up/down/left/right separately. This is cleaner and less error-prone than four separate if statements.	graphs::matrix_as_graph
How do you solve "Number of Islands" (count connected components in a matrix)?	For each unvisited land cell ('1'), run DFS/BFS to mark the entire island as visited. Count how many times you start a new traversal:<br><pre><code>def numIslands(grid):<br>    if not grid: return 0<br>    rows, cols = len(grid), len(grid[0])<br>    count = 0<br>    def dfs(r, c):<br>        if r<0 or r>=rows or c<0 or c>=cols or grid[r][c]!='1':<br>            return<br>        grid[r][c] = '0'  # mark visited (modify in-place)<br>        for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:<br>            dfs(r+dr, c+dc)<br>    for r in range(rows):<br>        for c in range(cols):<br>            if grid[r][c] == '1':<br>                count += 1<br>                dfs(r, c)  # sink the island<br>    return count</code></pre><br><b>Time: O(m×n), Space: O(m×n)</b> for call stack. Each cell is visited at most once. Modifying the grid in-place avoids a separate visited set.	graphs::matrix_as_graph
How does multi-source BFS work (e.g., Rotting Oranges)?	Start BFS from <b>ALL sources simultaneously</b> instead of a single start. All sources are at distance 0 in the queue:<br><pre><code>from collections import deque<br>def orangesRotting(grid):<br>    rows, cols = len(grid), len(grid[0])<br>    queue = deque()<br>    fresh = 0<br>    for r in range(rows):<br>        for c in range(cols):<br>            if grid[r][c] == 2: queue.append((r,c,0))<br>            elif grid[r][c] == 1: fresh += 1<br>    if fresh == 0: return 0<br>    max_time = 0<br>    while queue:<br>        r, c, time = queue.popleft()<br>        for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:<br>            nr, nc = r+dr, c+dc<br>            if 0<=nr<rows and 0<=nc<cols and grid[nr][nc]==1:<br>                grid[nr][nc] = 2  # rot it (also marks visited)<br>                fresh -= 1<br>                max_time = time + 1<br>                queue.append((nr, nc, time+1))<br>    return max_time if fresh == 0 else -1</code></pre><br><b>Time: O(m×n), Space: O(m×n)</b>. The BFS wavefront expands from all rotten oranges simultaneously, like ripples from multiple stones dropped in water.	graphs::matrix_as_graph
What is state-based BFS and when do you need it?	When BFS state includes more than just position — like "obstacles eliminated" or "keys collected" — the visited set must include the full state:<br><pre><code># Shortest path with at most k obstacle eliminations<br>def shortestPath(grid, k):<br>    rows, cols = len(grid), len(grid[0])<br>    queue = deque([(0, 0, k, 0)])  # r, c, remaining_k, dist<br>    visited = {(0, 0, k)}<br>    while queue:<br>        r, c, rem, dist = queue.popleft()<br>        if r == rows-1 and c == cols-1: return dist<br>        for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:<br>            nr, nc = r+dr, c+dc<br>            if 0<=nr<rows and 0<=nc<cols:<br>                new_rem = rem - grid[nr][nc]<br>                if new_rem >= 0 and (nr,nc,new_rem) not in visited:<br>                    visited.add((nr,nc,new_rem))<br>                    queue.append((nr,nc,new_rem,dist+1))<br>    return -1</code></pre><br>State: <code>(row, col, remaining_eliminations)</code>. Same cell with different remaining k values = different states. This is why visited is a set of tuples, not just positions.	graphs::matrix_as_graph
How do you solve "Flood Fill" (paint a connected region)?	DFS/BFS from the starting cell, changing all connected cells of the same color:<br><pre><code>def floodFill(image, sr, sc, color):<br>    orig = image[sr][sc]<br>    if orig == color: return image  # avoid infinite loop!<br>    rows, cols = len(image), len(image[0])<br>    def dfs(r, c):<br>        if r<0 or r>=rows or c<0 or c>=cols: return<br>        if image[r][c] != orig: return<br>        image[r][c] = color<br>        for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:<br>            dfs(r+dr, c+dc)<br>    dfs(sr, sc)<br>    return image</code></pre><br><b>Time: O(m×n), Space: O(m×n)</b>. Critical edge case: if <code>orig == color</code>, changing cells to the same color provides no visited marker → infinite loop. Check this first!	graphs::matrix_as_graph
How do you solve the "Surrounded Regions" problem?	Flip 'O' regions to 'X' UNLESS connected to the border. Trick: start from borders and mark safe regions, then flip everything else:<br><pre><code>def solve(board):<br>    rows, cols = len(board), len(board[0])<br>    def dfs(r, c):<br>        if r<0 or r>=rows or c<0 or c>=cols or board[r][c]!='O':<br>            return<br>        board[r][c] = 'S'  # safe (connected to border)<br>        for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:<br>            dfs(r+dr, c+dc)<br>    # Mark border-connected O's as safe<br>    for r in range(rows):<br>        for c in range(cols):<br>            if (r in (0,rows-1) or c in (0,cols-1)) and board[r][c]=='O':<br>                dfs(r, c)<br>    # Flip: S→O (safe), O→X (surrounded)<br>    for r in range(rows):<br>        for c in range(cols):<br>            if board[r][c] == 'O': board[r][c] = 'X'<br>            elif board[r][c] == 'S': board[r][c] = 'O'</code></pre><br><b>Time: O(m×n)</b>. The "reverse thinking" pattern: instead of finding surrounded regions (hard), find UN-surrounded regions from the border (easy).	graphs::matrix_as_graph
What is the matrix problem assessment framework?	Ask these questions in order to choose the right approach:<br><br><b>1. What am I looking for?</b><br>• Shortest path/distance → <b>BFS</b><br>• Count regions/components → <b>DFS or BFS</b><br>• Can I reach A from B? → <b>DFS</b><br>• All paths / explore all → <b>DFS + backtracking</b><br>• Optimal value (min cost, max path) → <b>DP or Dijkstra</b><br>• Transform/merge by relationship → <b>Build explicit graph</b><br>• Special traversal order → <b>Index manipulation</b><br><br><b>2. What defines the edges?</b><br>• Adjacent cells → direction array<br>• Non-spatial relationships → build adjacency list/dict<br><br><b>3. Are there weights/costs?</b><br>• Equal cost → BFS<br>• Variable costs → Dijkstra or DP<br><br><b>4. Extra state beyond position?</b><br>• Keys, obstacles remaining → state-based BFS	graphs::matrix_as_graph
How do you rotate a matrix 90° clockwise in-place?	<b>Two-step approach:</b> Transpose, then reverse each row:<br><pre><code>def rotate(matrix):<br>    n = len(matrix)<br>    # Step 1: Transpose (swap matrix[i][j] with matrix[j][i])<br>    for i in range(n):<br>        for j in range(i+1, n):<br>            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>    # Step 2: Reverse each row<br>    for row in matrix:<br>        row.reverse()</code></pre><br><b>Time: O(n²), Space: O(1)</b>. For counter-clockwise 90°: reverse each row THEN transpose (or transpose then reverse each column). For 180°: reverse each row, then reverse the array of rows.	graphs::matrix_traversal
How do you traverse a matrix in spiral order?	Track four boundaries (top, bottom, left, right) and shrink them as you go:<br><pre><code>def spiralOrder(matrix):<br>    result = []<br>    top, bottom = 0, len(matrix)-1<br>    left, right = 0, len(matrix[0])-1<br>    while top <= bottom and left <= right:<br>        for c in range(left, right+1): result.append(matrix[top][c])  # →<br>        top += 1<br>        for r in range(top, bottom+1): result.append(matrix[r][right])  # ↓<br>        right -= 1<br>        if top <= bottom:<br>            for c in range(right, left-1, -1): result.append(matrix[bottom][c])  # ←<br>            bottom -= 1<br>        if left <= right:<br>            for r in range(bottom, top-1, -1): result.append(matrix[r][left])  # ↑<br>            left += 1<br>    return result</code></pre><br><b>Time: O(m×n), Space: O(1)</b> excluding output. The <code>if</code> checks prevent double-counting when the remaining area is a single row or column.	graphs::matrix_traversal
How do you set matrix zeroes (mark rows/cols containing 0)?	Use the first row and first column as markers to achieve O(1) extra space:<br><pre><code>def setZeroes(matrix):<br>    rows, cols = len(matrix), len(matrix[0])<br>    first_row_zero = any(matrix[0][c] == 0 for c in range(cols))<br>    first_col_zero = any(matrix[r][0] == 0 for r in range(rows))<br>    # Mark zeros in first row/col<br>    for r in range(1, rows):<br>        for c in range(1, cols):<br>            if matrix[r][c] == 0:<br>                matrix[r][0] = 0<br>                matrix[0][c] = 0<br>    # Zero out marked rows/cols<br>    for r in range(1, rows):<br>        for c in range(1, cols):<br>            if matrix[r][0] == 0 or matrix[0][c] == 0:<br>                matrix[r][c] = 0<br>    if first_row_zero: matrix[0] = [0] * cols<br>    if first_col_zero:<br>        for r in range(rows): matrix[r][0] = 0</code></pre><br><b>Time: O(m×n), Space: O(1)</b>. The trick: use the matrix itself as storage for which rows/cols to zero, saving extra space.	graphs::matrix_traversal
How does Dijkstra's algorithm find shortest paths in weighted graphs?	BFS doesn't work for weighted graphs because closer distance ≠ fewer edges. Dijkstra uses a <b>min-heap</b> to always process the nearest unvisited node:<br><pre><code>import heapq<br>def dijkstra(graph, start):<br>    dist = {start: 0}<br>    heap = [(0, start)]  # (distance, node)<br>    while heap:<br>        d, node = heapq.heappop(heap)<br>        if d > dist.get(node, float('inf')): continue  # stale entry<br>        for neighbor, weight in graph[node]:<br>            new_dist = d + weight<br>            if new_dist < dist.get(neighbor, float('inf')):<br>                dist[neighbor] = new_dist<br>                heapq.heappush(heap, (new_dist, neighbor))<br>    return dist</code></pre><br><b>Time: O((V + E) log V), Space: O(V)</b>. The stale entry check (<code>if d > dist[node]</code>) is lazy deletion — when a node gets a better distance, the old heap entry becomes obsolete. Only works with <b>non-negative</b> weights.	graphs::algorithms
How do you detect a cycle in an undirected graph?	<b>DFS approach:</b> If you visit a node that's already visited and it's NOT the parent you came from, there's a cycle:<br><pre><code>def hasCycle(graph, n):<br>    visited = set()<br>    def dfs(node, parent):<br>        visited.add(node)<br>        for neighbor in graph[node]:<br>            if neighbor not in visited:<br>                if dfs(neighbor, node): return True<br>            elif neighbor != parent:<br>                return True  # back edge = cycle<br>        return False<br>    for i in range(n):<br>        if i not in visited:<br>            if dfs(i, -1): return True<br>    return False</code></pre><br><b>Time: O(V + E)</b>. The parent check prevents false positives from the edge you just traversed. Alternative: <b>Union-Find</b> — if two nodes in the same component get connected, that edge creates a cycle.	graphs::algorithms
How do you detect a cycle in a directed graph?	Use three states: <b>unvisited, in-progress, completed</b>. A cycle exists if you revisit an in-progress node (back edge):<br><pre><code>def hasCycle(graph, n):<br>    WHITE, GRAY, BLACK = 0, 1, 2<br>    color = [WHITE] * n<br>    def dfs(node):<br>        color[node] = GRAY  # in-progress<br>        for neighbor in graph[node]:<br>            if color[neighbor] == GRAY: return True  # cycle!<br>            if color[neighbor] == WHITE:<br>                if dfs(neighbor): return True<br>        color[node] = BLACK  # completed<br>        return False<br>    for i in range(n):<br>        if color[i] == WHITE:<br>            if dfs(i): return True<br>    return False</code></pre><br><b>Time: O(V + E)</b>. GRAY = currently on the DFS path (in the call stack). Visiting a GRAY node means you've found a back edge → cycle. BLACK nodes are fully processed and safe to revisit.	graphs::algorithms
What is topological sort and when do you use it?	Topological sort orders vertices of a DAG so that for every edge A→B, A appears before B. Used for <b>scheduling, dependency resolution, build orders</b>.<br><br><b>Kahn's Algorithm (BFS-based):</b><br><pre><code>from collections import deque<br>def topSort(graph, n):<br>    in_degree = [0] * n<br>    for u in graph:<br>        for v in graph[u]:<br>            in_degree[v] += 1<br>    queue = deque([i for i in range(n) if in_degree[i] == 0])<br>    order = []<br>    while queue:<br>        node = queue.popleft()<br>        order.append(node)<br>        for neighbor in graph[node]:<br>            in_degree[neighbor] -= 1<br>            if in_degree[neighbor] == 0:<br>                queue.append(neighbor)<br>    return order if len(order) == n else []  # empty = cycle</code></pre><br><b>Time: O(V + E)</b>. Start with all nodes having in-degree 0 (no dependencies). Process them, reduce neighbors' in-degrees, repeat. If result has fewer than V nodes, a cycle exists.	graphs::algorithms
How does DFS-based topological sort work?	Run DFS and add nodes to result in <b>post-order</b> (after processing all descendants), then reverse:<br><pre><code>def topSort(graph, n):<br>    visited = set()<br>    order = []<br>    in_cycle = [False]<br>    path = set()  # for cycle detection<br>    def dfs(node):<br>        if node in path: in_cycle[0] = True; return<br>        if node in visited: return<br>        path.add(node)<br>        visited.add(node)<br>        for neighbor in graph[node]:<br>            dfs(neighbor)<br>        path.remove(node)<br>        order.append(node)  # post-order<br>    for i in range(n):<br>        dfs(i)<br>    return order[::-1] if not in_cycle[0] else []</code></pre><br><b>Time: O(V + E)</b>. Post-order guarantees all dependencies of a node are processed before the node itself is appended. Reversing gives the correct topological order.	graphs::algorithms
How do you find all connected components in an undirected graph?	Run DFS/BFS from each unvisited node. Each traversal discovers one component:<br><pre><code>def connectedComponents(graph, n):<br>    visited = set()<br>    components = []<br>    def dfs(node, component):<br>        visited.add(node)<br>        component.append(node)<br>        for neighbor in graph[node]:<br>            if neighbor not in visited:<br>                dfs(neighbor, component)<br>    for i in range(n):<br>        if i not in visited:<br>            component = []<br>            dfs(i, component)<br>            components.append(component)<br>    return components</code></pre><br><b>Time: O(V + E), Space: O(V)</b>. This is the same pattern as "Number of Islands" — each unvisited starting point reveals a new component. Alternative: <b>Union-Find</b> with union operations for each edge, then group by root.	graphs::algorithms
How does Union-Find solve graph connectivity problems?	Union-Find tracks which nodes are in the same connected component with near-O(1) operations:<br><pre><code>class UnionFind:<br>    def __init__(self, n):<br>        self.parent = list(range(n))<br>        self.rank = [0] * n<br>        self.count = n  # number of components<br>    def find(self, x):<br>        if self.parent[x] != x:<br>            self.parent[x] = self.find(self.parent[x])  # path compression<br>        return self.parent[x]<br>    def union(self, x, y):<br>        px, py = self.find(x), self.find(y)<br>        if px == py: return False<br>        if self.rank[px] < self.rank[py]: px, py = py, px<br>        self.parent[py] = px<br>        if self.rank[px] == self.rank[py]: self.rank[px] += 1<br>        self.count -= 1<br>        return True</code></pre><br><b>Find/Union: O(α(n)) ≈ O(1)</b> amortized. Use for: number of islands, redundant connection (cycle detection), accounts merge, connected components, Kruskal's MST.	graphs::algorithms
How do you solve "Course Schedule" (detect if all courses can be taken)?	This is cycle detection in a directed graph. If there's a cycle in prerequisites, it's impossible:<br><pre><code>from collections import deque, defaultdict<br>def canFinish(numCourses, prerequisites):<br>    graph = defaultdict(list)<br>    in_degree = [0] * numCourses<br>    for course, prereq in prerequisites:<br>        graph[prereq].append(course)<br>        in_degree[course] += 1<br>    queue = deque([i for i in range(numCourses) if in_degree[i]==0])<br>    taken = 0<br>    while queue:<br>        node = queue.popleft()<br>        taken += 1<br>        for neighbor in graph[node]:<br>            in_degree[neighbor] -= 1<br>            if in_degree[neighbor] == 0:<br>                queue.append(neighbor)<br>    return taken == numCourses</code></pre><br><b>Time: O(V + E)</b>. This is Kahn's topological sort — if we can process all nodes, no cycle exists. If <code>taken < numCourses</code>, some nodes are stuck in a cycle with non-zero in-degree.	graphs::algorithms
How do you solve "Accounts Merge" (graph transformation problem)?	Emails in the same account are connected. Build a graph of email relationships, then find connected components:<br><pre><code>from collections import defaultdict<br>def accountsMerge(accounts):<br>    graph = defaultdict(set)<br>    email_to_name = {}<br>    for account in accounts:<br>        name = account[0]<br>        first_email = account[1]<br>        for email in account[1:]:<br>            graph[first_email].add(email)<br>            graph[email].add(first_email)<br>            email_to_name[email] = name<br>    visited = set()<br>    result = []<br>    def dfs(email, component):<br>        visited.add(email)<br>        component.append(email)<br>        for neighbor in graph[email]:<br>            if neighbor not in visited:<br>                dfs(neighbor, component)<br>    for email in graph:<br>        if email not in visited:<br>            component = []<br>            dfs(email, component)<br>            result.append([email_to_name[email]] + sorted(component))<br>    return result</code></pre><br><b>Key insight:</b> The input isn't a matrix — it's relationship data. Build an explicit graph, then use standard connected components. This is a <b>graph transformation</b> problem.	graphs::algorithms
How do you find the shortest path in an unweighted graph?	Standard BFS from source, tracking distances:<br><pre><code>from collections import deque<br>def shortestPath(graph, start, end):<br>    if start == end: return 0<br>    visited = {start}<br>    queue = deque([(start, 0)])<br>    while queue:<br>        node, dist = queue.popleft()<br>        for neighbor in graph[node]:<br>            if neighbor == end: return dist + 1<br>            if neighbor not in visited:<br>                visited.add(neighbor)<br>                queue.append((neighbor, dist + 1))<br>    return -1  # no path</code></pre><br><b>Time: O(V + E), Space: O(V)</b>. BFS guarantees shortest path in unweighted graphs because it explores all distance-d nodes before distance-(d+1) nodes. The first time you reach the target is guaranteed to be optimal.	graphs::algorithms
How do you check if a graph is bipartite (2-colorable)?	Try to color the graph with 2 colors using BFS. If any neighbor has the same color, it's not bipartite:<br><pre><code>from collections import deque<br>def isBipartite(graph):<br>    n = len(graph)<br>    color = [-1] * n<br>    for start in range(n):<br>        if color[start] != -1: continue<br>        color[start] = 0<br>        queue = deque([start])<br>        while queue:<br>            node = queue.popleft()<br>            for neighbor in graph[node]:<br>                if color[neighbor] == -1:<br>                    color[neighbor] = 1 - color[node]<br>                    queue.append(neighbor)<br>                elif color[neighbor] == color[node]:<br>                    return False<br>    return True</code></pre><br><b>Time: O(V + E)</b>. A graph is bipartite iff it contains no odd-length cycles. Useful for: assignment problems, checking if a graph can be split into two groups with no intra-group edges.	graphs::algorithms
How do you clone (deep copy) a graph?	Use a hash map to track old → new node mappings, then DFS/BFS to recreate edges:<br><pre><code>def cloneGraph(node):<br>    if not node: return None<br>    cloned = {}<br>    def dfs(original):<br>        if original in cloned: return cloned[original]<br>        copy = Node(original.val)<br>        cloned[original] = copy  # map before recursing (handles cycles)<br>        for neighbor in original.neighbors:<br>            copy.neighbors.append(dfs(neighbor))<br>        return copy<br>    return dfs(node)</code></pre><br><b>Time: O(V + E), Space: O(V)</b>. Critical: add to the map BEFORE recursing into neighbors. Otherwise, cycles cause infinite recursion. Each node is cloned exactly once.	graphs::algorithms
How do you find the number of provinces (connected components from adjacency matrix)?	The input is an adjacency matrix, not a spatial grid. Each row/column is a city, <code>isConnected[i][j]=1</code> means cities i and j are connected:<br><pre><code>def findCircleNum(isConnected):<br>    n = len(isConnected)<br>    visited = set()<br>    count = 0<br>    def dfs(city):<br>        visited.add(city)<br>        for neighbor in range(n):<br>            if isConnected[city][neighbor] == 1 and neighbor not in visited:<br>                dfs(neighbor)<br>    for i in range(n):<br>        if i not in visited:<br>            dfs(i)<br>            count += 1<br>    return count</code></pre><br><b>Time: O(n²), Space: O(n)</b>. Unlike "Number of Islands" where cells are nodes, here rows/columns are nodes and the matrix defines edges. Same connected-components logic, different graph representation.	graphs::algorithms
What is the "word ladder" BFS pattern (transform source to target)?	Each word is a node; edges connect words differing by one letter. BFS finds the shortest transformation:<br><pre><code>from collections import deque<br>def ladderLength(beginWord, endWord, wordList):<br>    wordSet = set(wordList)<br>    if endWord not in wordSet: return 0<br>    queue = deque([(beginWord, 1)])<br>    visited = {beginWord}<br>    while queue:<br>        word, length = queue.popleft()<br>        for i in range(len(word)):<br>            for c in 'abcdefghijklmnopqrstuvwxyz':<br>                new_word = word[:i] + c + word[i+1:]<br>                if new_word == endWord: return length + 1<br>                if new_word in wordSet and new_word not in visited:<br>                    visited.add(new_word)<br>                    queue.append((new_word, length + 1))<br>    return 0</code></pre><br><b>Time: O(n × L × 26)</b> where n = words, L = word length. This is an <b>implicit graph</b> — edges aren't given, you generate neighbors by trying all single-character changes.	graphs::algorithms
How do you find the "max area of island" in a matrix?	DFS from each unvisited land cell, counting cells in each island:<br><pre><code>def maxAreaOfIsland(grid):<br>    rows, cols = len(grid), len(grid[0])<br>    max_area = 0<br>    def dfs(r, c):<br>        if r<0 or r>=rows or c<0 or c>=cols or grid[r][c]!=1:<br>            return 0<br>        grid[r][c] = 0  # mark visited<br>        area = 1<br>        for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:<br>            area += dfs(r+dr, c+dc)<br>        return area<br>    for r in range(rows):<br>        for c in range(cols):<br>            if grid[r][c] == 1:<br>                max_area = max(max_area, dfs(r, c))<br>    return max_area</code></pre><br><b>Time: O(m×n), Space: O(m×n)</b>. Same as "Number of Islands" but <b>returns the count</b> from DFS instead of just marking. Each DFS call returns the size of the component it explored.	graphs::matrix_as_graph
How do you find redundant connection (cycle-creating edge) with Union-Find?	Process edges one by one. The first edge that connects two already-connected nodes creates a cycle:<br><pre><code>def findRedundantConnection(edges):<br>    uf = UnionFind(len(edges) + 1)<br>    for u, v in edges:<br>        if not uf.union(u, v):<br>            return [u, v]  # already connected = cycle<br>    return []</code></pre><br><b>Time: O(n × α(n)) ≈ O(n), Space: O(n)</b>. Union-Find is perfect here because you need to incrementally check connectivity as edges are added. If <code>find(u) == find(v)</code> before union, they're already in the same component and this edge is redundant.	graphs::algorithms
What are the key complexity comparisons for graph algorithms?	<b>Traversal:</b><br>• BFS / DFS: <b>O(V + E)</b> time, O(V) space<br><br><b>Shortest Path:</b><br>• Unweighted → BFS: <b>O(V + E)</b><br>• Weighted (no neg edges) → Dijkstra: <b>O((V+E) log V)</b><br>• Weighted (neg edges OK) → Bellman-Ford: <b>O(V × E)</b><br>• All pairs → Floyd-Warshall: <b>O(V³)</b><br><br><b>Connectivity:</b><br>• Connected components (DFS): <b>O(V + E)</b><br>• Union-Find per operation: <b>O(α(n)) ≈ O(1)</b><br><br><b>Ordering:</b><br>• Topological sort: <b>O(V + E)</b><br><br><b>Matrix as graph:</b> V = rows × cols, E = 4V (4-directional). So O(V + E) = O(m × n) for matrix BFS/DFS.	graphs::fundamentals
How do you find the shortest path in a matrix (BFS template)?	Standard matrix BFS with distance tracking:<br><pre><code>from collections import deque<br>def shortestPathMatrix(grid, start, end):<br>    rows, cols = len(grid), len(grid[0])<br>    queue = deque([(start[0], start[1], 0)])<br>    visited = {(start[0], start[1])}<br>    while queue:<br>        r, c, dist = queue.popleft()<br>        if (r, c) == end: return dist<br>        for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:<br>            nr, nc = r+dr, c+dc<br>            if (0<=nr<rows and 0<=nc<cols and<br>                grid[nr][nc] == 0 and (nr,nc) not in visited):<br>                visited.add((nr, nc))<br>                queue.append((nr, nc, dist+1))<br>    return -1</code></pre><br><b>Time: O(m×n), Space: O(m×n)</b>. Key detail: add to visited <b>when enqueueing</b>, not when dequeueing. This prevents the same cell from being added to the queue multiple times.	graphs::matrix_as_graph
What is the DP-on-matrix pattern (unique paths, min path sum)?	When movement is restricted (e.g., only right/down), use DP instead of BFS:<br><pre><code># Minimum Path Sum (can only move right or down)<br>def minPathSum(grid):<br>    rows, cols = len(grid), len(grid[0])<br>    dp = [[0]*cols for _ in range(rows)]<br>    dp[0][0] = grid[0][0]<br>    for r in range(rows):<br>        for c in range(cols):<br>            if r == 0 and c == 0: continue<br>            up = dp[r-1][c] if r > 0 else float('inf')<br>            left = dp[r][c-1] if c > 0 else float('inf')<br>            dp[r][c] = grid[r][c] + min(up, left)<br>    return dp[rows-1][cols-1]</code></pre><br><b>Time: O(m×n), Space: O(m×n)</b>, reducible to O(n) with rolling array.<br><br><b>When DP vs BFS:</b> If movement is restricted to specific directions (no revisiting), DP works and is simpler. If movement is unrestricted (any direction), use BFS/DFS because DP has no defined ordering.	graphs::matrix_as_graph
What are common pitfalls in graph and matrix problems?	<b>1. Forgetting to mark visited:</b> Infinite loops in cyclic graphs or when BFS revisits cells.<br><br><b>2. Wrong visited timing:</b> BFS: mark when <b>enqueueing</b>. DFS iterative: check after <b>popping</b>. Getting this wrong causes TLE from duplicates.<br><br><b>3. Modifying input unintentionally:</b> Using <code>grid[r][c] = 0</code> as visited marker destroys the input. Clone first if you need original data later.<br><br><b>4. Directed vs undirected confusion:</b> Adding edges in one direction for an undirected graph, or both directions for a directed graph.<br><br><b>5. Missing components:</b> Only running DFS/BFS from node 0. If the graph is disconnected, you must loop through ALL nodes.<br><br><b>6. Off-by-one in bounds:</b> Using <code><= rows</code> instead of <code>< rows</code> in boundary checks.	graphs::fundamentals
